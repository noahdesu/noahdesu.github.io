<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Distributed Search for Beal's Conjecture Counterexamples</title>
  <meta name="description" content="Distributed search for a counterexample to Beal&#39;s Conjecture!">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://noahdesu.github.io/2015/01/30/distributed-search-for-beals-conjecture-counterexamples.html">
  <link rel="alternate" type="application/rss+xml" title="makedist" href="http://noahdesu.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">makedist</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="/legion.html">Legion</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Distributed Search for Beal's Conjecture Counterexamples</h1>
    <p class="post-meta">Jan 30, 2015
    </p>
    <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="noahdesu">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </header>

  <article class="post-content">
    <h1>Distributed search for a counterexample to Beal&#39;s Conjecture!</h1>

<p>Beal&#39;s Conjecture says that if <code>a^x + b^y = c^z</code>, where a, b, c, x, y, and z are positive integers and x, y and z are all greater than 2, then a, b, and c must have a common prime factor.</p>

<p>There is a monetary prize offered by Andrew Beal for a proof or counterexample to the conjecture. More information about the prize can be found here <a href="http://www.ams.org/profession/prizes-awards/ams-supported/beal-prize">http://www.ams.org/profession/prizes-awards/ams-supported/beal-prize</a>. This project aims to expand the size of the counterexample search space covered compared to previous efforts by using a distributed search strategy.</p>

<h4>Previous Efforts</h4>

<ul>
<li><a href="http://norvig.com/beal.html">http://norvig.com/beal.html</a> </li>
<li><a href="http://www.danvk.org/wp/beals-conjecture/">http://www.danvk.org/wp/beals-conjecture/</a></li>
</ul>

<h4>Current Status</h4>

<p>Where are we at with the search? Below is a matrix describing the state of known past attempts, as well as my own using the distributed approach described here. Below <code>N</code> represents the spaces covered by Peter Norvig (<a href="http://norvig.com/beal.html">http://norvig.com/beal.html</a>), and the <code>D</code> at <code>1000x1000</code> was covered at <a href="http://www.danvk.org/wp/beals-conjecture/">http://www.danvk.org/wp/beals-conjecture/</a>. The cells marked <code>CURRENT</code> are the jobs I&#39;ve performed, and the results are available in the <code>results/</code> directory of this Git repository.</p>

<table><thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: left">p=7</th>
<th style="text-align: left">p=10</th>
<th style="text-align: left">p=30</th>
<th style="text-align: left">p=100</th>
<th style="text-align: left">p=1,000</th>
<th style="text-align: left">p=2000</th>
<th style="text-align: left">p=3,000</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><strong>b=100</strong></td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><strong>b=1,000</strong></td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">D</td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><strong>b=2,000</strong></td>
<td style="text-align: left">--</td>
<td style="text-align: left">--</td>
<td style="text-align: left">--</td>
<td style="text-align: left">--</td>
<td style="text-align: left">--</td>
<td style="text-align: left">CURRENT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><strong>b=3,000</strong></td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">--</td>
<td style="text-align: left">--</td>
<td style="text-align: left">CURRENT</td>
</tr>
<tr>
<td style="text-align: left"><strong>b=10,000</strong></td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><strong>b=100,000</strong></td>
<td style="text-align: left">N</td>
<td style="text-align: left">N</td>
<td style="text-align: left">--</td>
<td style="text-align: left">CURRENT</td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><strong>b=250,000</strong></td>
<td style="text-align: left">N</td>
<td style="text-align: left">--</td>
<td style="text-align: left">--</td>
<td style="text-align: left">CURRENT</td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

<h4>Problem Overview</h4>

<p>The conceptual strategy for conducting a counterexample search is to compute all possible points <code>(a, x, b, y, c, z)</code> and then evaluate the expression <code>a^x + b^y = c^z</code>. If the expression holds and the bases do not have a common prime factor, then a counterexample has been found.</p>

<p>The core challenge behind a counterexample search strategy is dealing with the enormous size of the space being examined. For instance, taking a maximum value for the bases and exponents of <code>1000</code> we end up with <code>1000^6</code> points. That number is so large that a 1GHz CPU that runs at 1 billion cycles per second will take 1 billion seconds just to execute <code>1000^6</code> 1 cycle instructions. Evaluating the expression <code>a^x + b^y = c^z</code> takes far more than 1 cycle, so we need to be smart about the search.</p>

<p>First we will describe the simplest algorithm for conducting a counterexample search, and then iteratively refine it with  various optimizations. Then we will show how scaling this simple algorithm hits a wall very quickly, and then describe additional optimizations that let us expand the search space past what is possible with the simple algorithm. The optimizations and search techniques that will be described have all been considered in previous efforts. Finally we&#39;ll describe our new implementation that distributes the problem allowing us to further scale the problem sizes being considered.</p>

<h2>Generation 1 Algorithm</h2>

<p>The following is a naive algorithm for conducting a search that computes every combination of the points <code>(a, x, b, y, c, z)</code> and then checks if the point represents a counterexample:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</code></pre></div>
<p>A candidate version of the <code>check</code> function might do something like the following:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="n">axby</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axby</span> <span class="o">==</span> <span class="n">cz</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;found counterexample:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span>
</code></pre></div>
<p>I ran this algorithm for 85 minutes. In that period of time <code>859,796,767</code> points were examined. Considering the size of the state space with maximum base and exponent values of <code>1000</code>, that is approximately <code>0.0000000859796767 %</code> of the total space covered. In reality it will probably run much slower because this short experiment didn&#39;t reach the very large exponents that take a lot of effort to compute. This test was written in Python, but even when written in optimized C, this strategy will simply not scale with search spaces this size. In order to make progress we need to cut down on the amount of work we are doing, as well as making the operations more efficient.</p>

<h3>Optimization 1</h3>

<p>Since <code>a^x + b^y</code> is commutative we don&#39;t have to bother also testing <code>b^y + a^x</code>. This can be incorporated into the algorithm above by adjusting the upper bound of the values assigned to <code>b</code>:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div>
<p>This filter reduces by 50% the number of points that must be considered. The problem is that the search space is so large that even with a 50% reduction in size it is still much too large. But we certainly want to use any optimizations we can find.</p>

<h3>Optimization 2</h3>

<p>Since we only care about counterexamples we don&#39;t need to check any points where the bases have a common prime. This means that when iterating over the points in the space we can skip all points for which any two of the bases (e.g. <code>a</code> and <code>b</code>) have a common prime factor.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fractions</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="o">...</span>
</code></pre></div>
<p>This is actually a pretty nice optimization. Even though computing <code>gcd</code> isn&#39;t cheap, we only have to do it roughly <code>max_base * (max_base + 1) / 2</code> times, and what we get in return is the ability to completely skip the rest of the nested for loops for that combination of <code>(a, b)</code> values.</p>

<h3>Optimization 3</h3>

<p>Notice that in the algorithm above that computes all combinations of <code>(a, x, b, y, c, z)</code> the outer four for loops compute the possible values of <code>a^x + b^y</code> (the left-hand-side), and the inner most two for loops compute all possible values of <code>c^z</code> to which a particular left-hand-side value is compared. Recomputing all possible <code>c^z</code> values is very expensive! An alternative is to pre-compute all possible values for <code>c^z</code> and save them in a data structure that can be searched. Then, given a left-hand-side value we can search for the corresponding match among the pre-computed values. If that search is cheaper than re-computing the values then we will speed-up the overall search.</p>

<p>The following is a revised version of our algorithm that pre-computes the <code>c^z</code> values and stores them in a Python dictionary. Note that below the main search loop only generates combinations of <code>a^x + b^y</code>, significantly reducing the amount of work we have to do.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">cz_values</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>

<span class="c"># populate c^z table: one time cost</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">cz_values</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>

<span class="c"># generate left-hand-side values</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div>
<p>And now the <code>check</code> function can avoid computing all <code>c^z</code> values, opting instead for a fast hash-table lookup:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">axby</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axby</span> <span class="ow">in</span> <span class="n">cz_values</span><span class="p">:</span> <span class="c"># avoid empty list creation</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">cz_values</span><span class="p">[</span><span class="n">axby</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;counterexample found:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span>
</code></pre></div>
<p>It may cost a few seconds to pre-compute all of the <code>c^z</code> values for a very large search space, but since we get to amortize that cost across the all points in the space we effectively reduce the cost of the search by a factor proportional to the size of the <code>c^z</code> space!</p>

<h3>Optimization 4</h3>

<p>Notice that to compute the values of <code>c^z</code> to store in a search structure we also compute all of the powers that are needed for evaluating <code>a^x + b^y</code>. Since <code>pow</code> isn&#39;t a cheap function, we can also save each value to avoid recomputing terms in the equation. Here we modify the way we populate the <code>c^z</code> search structure to also cache the individual powers:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">cz_values</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span> <span class="c"># pow(c, z) -&gt; { (c, z) }</span>
<span class="n">powers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{})</span>    <span class="c">#    (c, z) -&gt; pow(c, z)</span>

<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">cz_values</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
        <span class="n">powers</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="o">...</span>
</code></pre></div>
<p>Then in the <code>check</code> function we lookup each <code>a^x</code> and <code>b^y</code> to avoid the expensive computation of the <code>pow</code> function.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">axby</span> <span class="o">=</span> <span class="n">powers</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">powers</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">axby</span> <span class="ow">in</span> <span class="n">cz_values</span><span class="p">:</span> <span class="c"># avoid empty list creation</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">cz_values</span><span class="p">[</span><span class="n">axby</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;counterexample found:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span>
</code></pre></div>
<p>Now we are getting somewhere. This approach closely resembles the approach used by Peter Norvig here <a href="http://norvig.com/beal.html">http://norvig.com/beal.html</a>, with the exception that there are some more efficient ways to cache data and build the search structure. Even in Python, this approach is pretty speedy. Norvig reports results for several different search spaces, including 3 minutes for <code>max_base = max_pow = 100</code>. Unfortunately the costs explode with large spaces such as 19 hours for  <code>max_pow = 1000</code> and <code>max_base = 100</code>, and 39 days <code>max_pow = 100</code> and <code>max_base = 10,000</code>. </p>

<p>We can distribute the search problem by assigning worker nodes disjoint partitions of the search space. However, the mechanism we have described uses infinite precision arithmetic which adds a lot of overhead both in time and space, limiting per-node scalability. For instance, the value <code>1000^1000</code> contains about 3000 digits. Operations on numbers this large can&#39;t be performed as efficiently compared to numbers that are stored in 64-bit registers.</p>

<p>In the previous approach described here <a href="http://norvig.com/beal.html">http://norvig.com/beal.html</a>, Peter Norvig proposed doing all arithmetic modulo large 64-bit prime numbers. This has the advantage that all operations are very efficient, but results may be false positives and must be verified. However, if we can sufficiently reduce the number of potential counterexamples, the savings realized from performing verification using infinite precision arithmetic on a small percentage of the total space may be far outweighed by the cost of using infinite precision arithmetic exclusively. This is exactly the approach taken in <a href="http://www.danvk.org/wp/beals-conjecture/">http://www.danvk.org/wp/beals-conjecture/</a>. Next I&#39;ll describe how to incorporate modulo arithmetic to make the search more efficient.</p>

<h1>Generation 2 Algorithm</h1>

<p>In the previous section we described the 1st generation algorithm and a set of optimizations that significantly improve performance over a naive implementation. However, the 1st generation algorithm used infinite precision arithmetic which limits scalability because of the costs associated with operations on large numbers. Performing modulo arithmetic can circumvent the problem.</p>

<p>The motivation for using modulo arithmetic is to reduce the number of bits needed to represent the values we are working with. While space savings is important, numeric operations on values that fit into CPU registers are extremely fast compared to the algorithms used to perform infinite precision arithmetic. The approach is based off the observation that if <code>a^x + b^y = c^z</code> then for a value <code>p1</code>, <code>(a^x + b^y) mod p1 = c^z mod p1</code>. By keeping <code>p1</code> small enough, we can force all values to fit within a CPU register. For instance, <code>789^999</code> is a number with 2895 digits. However, <code>789^999 mod 4294967291</code> is <code>1153050910</code> which easily fits into a 64-bit CPU register.</p>

<p>The obvious problem with sacrificing precision is false positives. That is, the space of possible values is far greater than the size of the modulo meaning that many distinct values may be identical modulo the same number. So how do we reduce the number of false positives? Observing that if two numbers are identical modulo a value <code>p1</code> then they are identical modulo a different value <code>p2</code>, we can construct a simple filter by performing arithmetic modulo multiple numbers and ensuring that equality holds in all cases. There is a more detailed description of this approach written about here <a href="http://www.danvk.org/wp/beals-conjecture/">http://www.danvk.org/wp/beals-conjecture/</a>, which also describes why large prime numbers are good choice for the modulus.</p>

<p>The changes to the algorithm are relatively modest. Each of the search structures used to store and cache the <code>c^z</code> values is parameterized on the prime numbers. So for instance to look up <code>10^20 mod 4294967291</code> we use <code>powers[4294967291][10][20]</code>.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4294967291</span><span class="p">,</span> <span class="mi">4294967279</span><span class="p">]</span>
<span class="n">cz_values</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">powers</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c"># parameterize structures on prime values</span>
<span class="k">for</span> <span class="n">prime</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
    <span class="n">cz_values</span><span class="p">[</span><span class="n">prime</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>
    <span class="n">powers</span><span class="p">[</span><span class="n">prime</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{})</span>

<span class="c"># compute c^z modulo each prime value</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_base</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pow</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prime</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">prime</span><span class="p">)</span>
            <span class="n">cz_values</span><span class="p">[</span><span class="n">prime</span><span class="p">][</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
            <span class="n">powers</span><span class="p">[</span><span class="n">prime</span><span class="p">][</span><span class="n">c</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="o">...</span>
</code></pre></div>
<p>The loop construct used to generate all of the <code>(a, x, b, y)</code> values is the same, and the remaining changes are in the <code>check</code> function where we ensure that equality holds modulo each prime number.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">candidates_found</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">prime</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
        <span class="n">axby</span> <span class="o">=</span> <span class="p">(</span><span class="n">powers</span><span class="p">[</span><span class="n">prime</span><span class="p">][</span><span class="n">a</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">powers</span><span class="p">[</span><span class="n">prime</span><span class="p">][</span><span class="n">b</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="o">%</span> <span class="n">prime</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">axby</span> <span class="ow">in</span> <span class="n">cz_values</span><span class="p">[</span><span class="n">prime</span><span class="p">]:</span>
            <span class="n">candidates_found</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># done... needs to be true for all primes</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">cz_values</span><span class="p">[</span><span class="n">prime</span><span class="p">][</span><span class="n">axby</span><span class="p">]:</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">candidates_found</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">candidates</span>
</code></pre></div>
<p>This is quite a lot faster than the generation 1 algorithm. We can search the space associated the parameters <code>max_base = max_pow = 100</code> in about 20 seconds, compared to 3 minutes with the previous version. The time savings is realized by using small fixed-size numbers.</p>

<p>In the next section we describe an implementation in C++ that is designed to be distributed such that disjoint partitions of the search space are handled by independent workers, allowing us to scale out the search and reduce the costs of searching larger spaces.</p>

<h1>Generation 3</h1>

<p>The implementation found in this repository contains all of the above optimizations, but adds the ability to decompose the problem and perform the search in parallel across any number of worker nodes. The high-level structure of the solution is for each worker node to host a copy of the <code>c^z</code> space such that it can examine any partitioning of the <code>a^x + b^y</code> space. Since the <code>c^z</code> space is relatively small, we try much larger spaces without worrying about memory pressure. A master node computes partitions, responds to requests for work, and records results from worker nodes.</p>

<h2>Manager</h2>

<p>The manager process (<code>prob-manager.py</code>) exposes two RPC endpoints <code>get_work</code> and <code>finish_work</code>. The partitioning of the <code>a^x + b^y</code> space is very simple, handing out distinct values for <code>a</code> (smarter partitioning is needed for expanding the search in certain ways, but this works for now). When a worker requests a partitioning the the master process will run the following, where <code>__get_work()</code> returns a distinct <code>a</code> value:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_work</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">part</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">work_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;max_base&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxb</span><span class="p">,</span>
                <span class="s">&#39;max_pow&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxp</span><span class="p">,</span>
                <span class="s">&#39;primes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_primes</span><span class="p">,</span>
                <span class="s">&#39;part&#39;</span><span class="p">:</span> <span class="n">part</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">work_spec</span>
</code></pre></div>
<p>When a worker completes a search it responds to the <code>finish_work</code> RPC endpoint. A completed work unit contains enough information to detect duplicates, as well as all of the candidate solutions that the worker found. The master writes all of the candidates out to a single file.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">finish_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
        <span class="n">dupe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_work_queue</span><span class="o">.</span><span class="n">complete</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dupe</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_output</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="k">print</span> <span class="n">result</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
</code></pre></div>
<h2>Worker</h2>

<p>The worker process (<code>prob-worker.py</code>) is responsible for handling a partition of the <code>a^x + b^y</code> space. The following code snippet is run by each worker. In an infinite loop a work unit is retrieved, a context is created (see below), a search is performed, and the results are returned to the manager.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">work_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_server</span><span class="o">.</span><span class="n">get_work</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">work_spec</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;no work available... waiting&quot;</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">setup_context</span><span class="p">(</span><span class="n">work_spec</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;part&#39;</span><span class="p">]</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_server</span><span class="o">.</span><span class="n">finish_work</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hits</span><span class="p">))</span>
</code></pre></div>
<p>Note above that for each work unit a new context is created (i.e. <code>setup_context()</code>). A context contains all of the data structures used to perform a search and can take some time to setup. Currently a worker guarantees that a context is compatible with each work unit, but doesn&#39;t attempt to switch contexts after the first work unit is retrieved. This is primarily just for simplicity:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">search</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">setup_context</span><span class="p">(</span><span class="n">work_spec</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">search</span>
    <span class="n">max_base</span> <span class="o">=</span> <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;max_base&#39;</span><span class="p">]</span>
    <span class="n">max_pow</span> <span class="o">=</span> <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;max_pow&#39;</span><span class="p">]</span>
    <span class="n">primes</span> <span class="o">=</span> <span class="n">work_spec</span><span class="p">[</span><span class="s">&#39;primes&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">search</span><span class="p">:</span>
        <span class="n">search</span> <span class="o">=</span> <span class="n">beal</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">max_base</span><span class="p">,</span> <span class="n">max_pow</span><span class="p">,</span> <span class="n">primes</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">assert</span> <span class="n">max_base</span> <span class="o">==</span> <span class="n">search</span><span class="o">.</span><span class="n">max_base</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">max_pow</span>  <span class="o">==</span> <span class="n">search</span><span class="o">.</span><span class="n">max_pow</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">primes</span>   <span class="o">==</span> <span class="n">search</span><span class="o">.</span><span class="n">primes</span><span class="p">()</span>
</code></pre></div>
<p>So where is the search actually performed? Well Python can be quite slow at computation, but it is fantastic at tasks such as coordinating work and handling network communication. So we&#39;ve chosen to implement all the performance critical parts in C.</p>

<h2>GCD and Modular Exponentiation</h2>

<p>Implementations of GCD and fast modular exponentation are found in <code>math.h</code>. The following were taken from Wikipedia and ported to C from psuedo code. I&#39;ve only included <code>modpow</code> here:</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="cm">/*</span>
<span class="cm"> * http://en.wikipedia.org/wiki/Modular_exponentiation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">modpow</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">base</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">exponent</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="p">(((</span><span class="mi">1ULL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>
</code></pre></div>
<p>So how do we go about testing the implementation? After all, these are crucial to the correctness of the search. What we&#39;ve done is used Python to coordinate a large number of tests and compare the results to a separate implementation of each algorithm.</p>

<p>In <code>beal.cc</code> we have all of the C implementations, and then we bind from Python. First we create a simple C wrapper:</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="kt">uint32_t</span> <span class="nf">c_modpow</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">base</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">exponent</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">modpow</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">c_gcd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>And in <code>beal.py</code> we create the bindings:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">cffi</span>

<span class="n">_ffi</span> <span class="o">=</span> <span class="n">cffi</span><span class="o">.</span><span class="n">FFI</span><span class="p">()</span>
<span class="n">_libbeal</span> <span class="o">=</span> <span class="n">_ffi</span><span class="o">.</span><span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;./libbeal.so&quot;</span><span class="p">)</span>
<span class="n">_ffi</span><span class="o">.</span><span class="n">cdef</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">uint32_t c_modpow(uint64_t base, uint64_t exponent, uint32_t mod);</span>
<span class="s">unsigned int c_gcd(unsigned int u, unsigned int v);</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">modpow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_libbeal</span><span class="o">.</span><span class="n">c_modpow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_libbeal</span><span class="o">.</span><span class="n">c_gcd</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div>
<p>To actually perform the tests we can compute values in Python and compare the values to what is computed by the C versions. In the following snippet <code>__check</code> will use Python built-in function <code>pow</code> and compare to our implementation. We&#39;ve removed some of the tests here (see <code>test.py</code>), but <code>test_random</code> effectively generates a large number of random values to check. Note the <code>test_specific</code> function where we had actually found a problem in one version of the algorithm on Wikipedia (the fix had already been added after I had snatched the code a while back). </p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">TestModPow</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">value1</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">value2</span> <span class="o">=</span> <span class="n">beal</span><span class="o">.</span><span class="n">modpow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span>
                <span class="s">&quot;</span><span class="si">%d</span><span class="s"> != </span><span class="si">%d</span><span class="s">: </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">test_random</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">7</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">expo</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__check</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">expo</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_specific</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># random testing found a problem with c_modpow for these inputs. the</span>
        <span class="c"># fix was to include `base = base % mod` before starting the loop in</span>
        <span class="c"># the modpow algo, as is done in the wikipedia algorithm.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check</span><span class="p">(</span><span class="mi">4542062976100348463</span><span class="p">,</span> <span class="mi">4637193517411546665</span><span class="p">,</span> <span class="mi">3773338459</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check</span><span class="p">(</span><span class="mi">70487458014159955</span><span class="p">,</span> <span class="mi">5566498974156504764</span><span class="p">,</span> <span class="mi">3541295600</span><span class="p">)</span>
</code></pre></div>
<p>Similarily, to test GCD we use the Python library function <code>fractions.gcd</code> to compute a value to compare to our C version:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">TestGCD</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">value1</span> <span class="o">=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">value2</span> <span class="o">=</span> <span class="n">beal</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="s">&quot;</span><span class="si">%u</span><span class="s"> </span><span class="si">%u</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">test_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__check</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div>
<h2>The c^z Context</h2>

<p>For each prime value used as a filter we create a <code>cz</code> class that contains search structures used to quickly find candidate solutions. The private variable <code>std::vector&lt;std::vector&lt;uint32_t&gt; &gt; vals_</code> is used to avoid recomputing the exponential terms in <code>a^x + b^y</code>. When performing the actual search we avoid using any type of hash table, and instead exploit the 32-bit bound on prime values by created a 4GB sparse array, represented by the private variable <code>std::vector&lt;bool&gt; exists_;</code>. Note in the constructor that we only set the bits to true that correspond to values found in the <code>c^z</code> space.</p>

<p>Finally, the <code>get</code> and <code>exists</code> methods are used to interface to the data structures.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">cz</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">cz</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">maxb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">maxp</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">mod</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">vals_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">maxb</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">exists_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1ULL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">maxb</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">vals_</span><span class="p">[</span><span class="n">c</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">maxp</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">maxp</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">val</span> <span class="o">=</span> <span class="n">modpow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
        <span class="n">vals_</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">exists_</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">mod_</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">vals_</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">z</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">exists</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">exists_</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="n">mod</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">mod_</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vals_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">exists_</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">mod_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>To test the <code>cz</code> class we again coordinate things with Python. At a high-level we construct a <code>cz</code> class and then assert various properties. The <code>__check</code> method is responsible for this. First we create the <code>cz</code> instance:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">TestCz</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="n">cz</span> <span class="o">=</span> <span class="n">beal</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
</code></pre></div>
<p>Next we recompute all of the values in Python and ensure that we are able to retrieve the same value through the <code>get</code> interface, and that their value is found with the <code>exists</code> interface:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">        <span class="n">values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxb</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">maxp</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">value1</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
                <span class="n">value2</span> <span class="o">=</span> <span class="n">cz</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="n">cz</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">exists</span><span class="p">)</span>
</code></pre></div>
<p>Ideally we would like to guarantee that the interface doesn&#39;t return false negatives, but this requires querying all values from 0 to 2^32. In the interest of time we compromise by checking a set of random values:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">        <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">8</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="n">cz</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>

        <span class="n">cz</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
</code></pre></div>
<p>And that is it. In <code>test.py</code> you can see we call <code>__check</code> with several different sets of parameters. For instance we generate some random parameters:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">def</span> <span class="nf">test_random</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
            <span class="n">maxb</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
            <span class="n">maxp</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__check</span><span class="p">(</span><span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
</code></pre></div>
<h2>Work Context</h2>

<p>The context that we setup for a search is primarily just one <code>cz</code> class instance per prime number used as a filter. We organize these instances in the <code>work</code> class. See below in the constructor that we create a <code>cz</code> instance for each prime:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">work</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">work</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">primes</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nprimes</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">maxb_</span><span class="p">(</span><span class="n">maxb</span><span class="p">),</span> <span class="n">maxp_</span><span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nprimes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">czs_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">cz</span><span class="p">(</span><span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">work</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">czs_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="k">delete</span> <span class="n">czs_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
</code></pre></div>
<p>The real work happens in <code>do_work</code> that takes as input the partition of <code>a^x + b^y</code> to search (defined currently by a value for <code>a</code>), and returns a set of <code>(a,x,b,y)</code> candidate points as the result. First we create an <code>axby</code> class instance that manages the iteration over the points we will be searching:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="nf">do_work</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">axby</span><span class="o">::</span><span class="n">point</span><span class="o">&gt;&amp;</span> <span class="n">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">done</span><span class="p">;</span>
    <span class="n">axby</span> <span class="n">pts</span><span class="p">(</span><span class="n">maxb_</span><span class="p">,</span> <span class="n">maxp_</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

    <span class="n">axby</span><span class="o">::</span><span class="n">point</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">pts</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div>
<p>Now, for each point and for each prime filter we calculate <code>a^x + b^y mod prime</code> and search for candidates in the corresponding <code>cz</code> instance, collecting the results in an output vector:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">      <span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">czs_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cz</span> <span class="o">*</span><span class="n">czp</span> <span class="o">=</span> <span class="n">czs_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">uint64_t</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">czp</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">pt</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">pt</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
        <span class="kt">uint64_t</span> <span class="n">by</span> <span class="o">=</span> <span class="n">czp</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">pt</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="n">pt</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="kt">uint64_t</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="o">+</span> <span class="n">by</span><span class="p">)</span> <span class="o">%</span> <span class="n">czp</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">czp</span><span class="o">-&gt;</span><span class="n">exists</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
        <span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>

      <span class="n">pt</span> <span class="o">=</span> <span class="n">pts</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">maxb_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">maxp_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cz</span><span class="o">*&gt;</span> <span class="n">czs_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>That is a summary of the core approach to the search strategy implementation. The only remaining component is the iteration of the <code>(a,x,b,y)</code> points.</p>

<h2>a^x + b^y Point Iteration</h2>

<p>We use an <code>axby</code> helper class to iterate over point to check. It is partitioned by values of <code>a</code>. That is, the starting point is a value for the <code>a</code> dimension. All points will be generated and the normal trimming optimizations will be applied. First initialize the class with the starting <code>a</code> value:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">axby</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">struct</span> <span class="n">point</span> <span class="p">{</span>
    <span class="n">point</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">axby</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">maxb_</span><span class="p">(</span><span class="n">maxb</span><span class="p">),</span> <span class="n">maxp_</span><span class="p">(</span><span class="n">maxp</span><span class="p">),</span> <span class="n">p_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">a_dim_</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">maxb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">maxp</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">p_</span><span class="p">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">p_</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">p_</span><span class="p">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">p_</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">p_</span><span class="p">.</span><span class="n">y</span><span class="o">--</span><span class="p">;</span> <span class="c1">// first next() call will be starting point</span>
  <span class="p">}</span>
</code></pre></div>
<p>The following is an iterator over the points. It is specialized for the case of a fixed <code>a</code> value, but can easily be used to generate an entire space, or modified to perform other iteration strategies:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="kr">inline</span> <span class="n">point</span><span class="o">&amp;</span> <span class="n">next</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">p_</span><span class="p">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">a_dim_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">p_</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">maxp_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">p_</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">p_</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxp_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p_</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">p_</span><span class="p">.</span><span class="n">b</span><span class="o">++</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">p_</span><span class="p">.</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">p_</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// this is where b rolls over. when generating the entire space of</span>
            <span class="c1">// points this is the point we would increment &quot;a&quot;. For example:</span>
            <span class="c1">//</span>
            <span class="c1">//   p_.b = 1;</span>
            <span class="c1">//   if (++p_.a &gt; maxb_) {</span>
            <span class="c1">//     *done = true;</span>
            <span class="c1">//     return p_;</span>
            <span class="c1">//   }</span>
            <span class="c1">//</span>
            <span class="c1">// Since we only want to iterate over the space for a given &quot;a&quot;</span>
            <span class="c1">// value this is the point we return `done = true` to the caller.</span>

            <span class="c1">// bump p_.a so we can assert on its uniqueness</span>
            <span class="n">p_</span><span class="p">.</span><span class="n">a</span><span class="o">++</span><span class="p">;</span>
            <span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">p_</span><span class="p">;</span>

          <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">p_</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">p_</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p_</span><span class="p">.</span><span class="n">b</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p_</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">maxb_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">maxp_</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">point</span> <span class="n">p_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a_dim_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>So, that&#39;s it. Testing the <code>axby</code> class is fairly basic. For each <code>a</code> value in a range we create a new <code>axby</code> iterator instance:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">TestAxby</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_all_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">maxb</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="n">maxp</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxb</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">axby</span> <span class="o">=</span> <span class="n">beal</span><span class="o">.</span><span class="n">axby</span><span class="p">(</span><span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div>
<p>Then we iterate over the space in Python and assert that the <code>axby</code> iterator implemented in C++ returns the exact same sequence:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fractions</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">maxp</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">maxp</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">done</span><span class="p">,</span> <span class="n">point</span> <span class="o">=</span> <span class="n">axby</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                        <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="n">done</span><span class="p">)</span>
                        <span class="n">aa</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">point</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">aa</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yy</span><span class="p">)</span>
            <span class="n">done</span><span class="p">,</span> <span class="n">point</span> <span class="o">=</span> <span class="n">axby</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
            <span class="n">axby</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
</code></pre></div>
<p>Putting it all together, we can test an entire state space search.</p>

<h2>End-to-end Testing</h2>

<p>We&#39;ll need something to compare our results to. We&#39;ve taken the results published at <a href="http://www.danvk.org/wp/beals-conjecture/">http://www.danvk.org/wp/beals-conjecture/</a> for a <code>1000x1000</code> state space, and also used the published code on that website to generate several other reference data sets. These results are stored in the <code>gold/</code> directory. First we load all of the gold results into a set:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">TestSearch</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="n">PRIMES</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4294967291</span><span class="p">,</span> <span class="mi">4294967279</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__get_gold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&quot;(\d+)\^(\d+) \+ (\d+)\^(\d+)&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;gold/danvk_</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
                <span class="n">results</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>
</code></pre></div>
<p>Finally, we use all of our code to perform a state space search one <code>a</code> value at a time, simulating the distribution of the problem. See <code>test.py</code> for checking other problem sizes.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">def</span> <span class="nf">__check_gold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">primes</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">search</span> <span class="o">=</span> <span class="n">beal</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">primes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxb</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hits</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_gold</span><span class="p">(</span><span class="n">maxb</span><span class="p">,</span> <span class="n">maxp</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">test_1000x1000</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_gold</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PRIMES</span><span class="p">)</span>
</code></pre></div>
<h1>Open Questions</h1>

<ul>
<li>Are there other ways that the state space can be trimmed?</li>
<li>Are there classes of points that are more interesting to test (e.g. large exponents)?</li>
<li>Are there methods for making the modulo-based filtering more effective (e.g. larger primes)</li>
<li>What improvements can we get by using GPU-based acceleration (e.g. CUDA or OpenCL)?</li>
<li>Can we make searching the <code>c^z</code> space even faster by taking advantage of cache locality?</li>
</ul>

<p>The following discussion about new approaches is quoted from <a href="http://norvig.com/beal.html:">http://norvig.com/beal.html:</a></p>

<blockquote>
<p>Beyond that, we need a new approach. My first idea is to only do a slice of the zr values at a time. This would require &gt;switching from an approach that limits the bases and powers to one that limits the minimum and maximum sum searched for. &gt;That is, we would call something like beal2(10 ** 20, 10 ** 50) to search for all solutions with sum between 1020 and 1050. &gt;The program would build a table of all zr values in that range, and then carefully enumerate x,m,y,n to stay within that &gt;range. One could then take this program and add a protocol like SETI@home where interested people could download the code, &gt;be assigned min and max values to search on, and a large network of people could together search for solutions.</p>

<p>Ultimately, I think that if there are any counterexamples at all, they will probably be found through generating functions &gt;based on elliptical curves, or some other such approach. But that&#39;s too much math for me; I&#39;m just trying to apply the &gt;minimal amount of computer programming to look for the &quot;obvious&quot; counterexamples.</p>
</blockquote>

  </article>

  <section id="disqus_thread"></section>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'noahdesugithubcom'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">makedist</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>makedist</li>
          <li><a href="mailto:noahwatkins@gmail.com">noahwatkins@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/noahdesu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/noahdesu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Notes on programming, research, and other interests.
</p>
      </div>
    </div>

  </div>

</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37966177-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>

</html>
