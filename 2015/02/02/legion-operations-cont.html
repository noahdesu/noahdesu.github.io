<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Legion Runtime Class #4: Operations, Continued</title>
  <meta name="description" content="About Legion Runtime Class">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://noahdesu.github.io/2015/02/02/legion-operations-cont.html">
  <link rel="alternate" type="application/rss+xml" title="makedist" href="http://noahdesu.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">makedist</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="/legion.html">Legion</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Legion Runtime Class #4: Operations, Continued</h1>
    <p class="post-meta">Feb 2, 2015
    </p>
    <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="noahdesu">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </header>

  <article class="post-content">
    <h1>About Legion Runtime Class</h1>

<p>These notes are closely based on the set
of <a href="http://www.youtube.com/playlist?list=PLUNK9XcztK7xjXfppL9hIpVv2ukp7A4tG">Legion Runtime
Class</a>
videos produced by the <a href="http://legion.stanford.edu">Legion</a> developers. They are my own notes and code walks, and any
errors or things that are just plain wrong represent my own mistakes.</p>

<p>Today&#39;s notes are based on the following video:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/1LQ3anlqztI?list=PLUNK9XcztK7xjXfppL9hIpVv2ukp7A4tG" frameborder="0" allowfullscreen></iframe>

<h2>Overview</h2>

<p>The <code>CopyOp</code> is an operation that copies data between two logical regions, most likely between different region trees. The motivation for the creation of this operation is that users have created their own routines for performing such copies, but the runtime already has a lot of infrastructure for high performance copying, and exposing that as an operation lets user take advantage of those facilities found the runtime.</p>

<p>The first difference to notice between the <code>CopyOp</code> and the inline mapping operation <code>MapOp</code> discussed last time is that the <code>CopyOp</code> extends the <code>SpeculativeOp</code> abstract operation class.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">CopyOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Copy</span><span class="p">,</span> <span class="k">public</span> <span class="n">SpeculativeOp</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">AllocationType</span> <span class="n">alloc_type</span> <span class="o">=</span> <span class="n">COPY_OP_ALLOC</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">CopyOp</span><span class="p">(</span><span class="n">Runtime</span> <span class="o">*</span><span class="n">rt</span><span class="p">);</span>
    <span class="n">CopyOp</span><span class="p">(</span><span class="k">const</span> <span class="n">CopyOp</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">CopyOp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div>
<p>The <code>CopyOp</code> begins its life at <code>Runtime::issue_copy_operation</code>. The first thing that happens is we grab a copy operation from one of the operation pools that is maintained by the runtime:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">issue_copy_operation</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">CopyLauncher</span> <span class="o">&amp;</span><span class="n">launcher</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CopyOp</span> <span class="o">*</span><span class="n">copy_op</span> <span class="o">=</span> <span class="n">get_available_copy_op</span><span class="p">();</span>
  <span class="n">copy_op</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">launcher</span><span class="p">,</span> <span class="nb">false</span><span class="cm">/*check privileges*/</span><span class="p">);</span>
</code></pre></div>
<p>Initialization of the copy operation involves a lot of work. For instance, the region requirements of the source and destination regions are copied into the operation from the launcher object. Information is passed along that the copy operation, despite performing mappings, won&#39;t be actually be accessed by a task and can thus there is more flexibility over the memories that can be chosen. During initialization there is a lot of error checking for compatibility and privileges, but won&#39;t go into detail regarding that.</p>

<p>Once the operation is initialized we resume back in <code>issue_copy_operation</code>. The next thing we do is look for conflicts. Note that when we issue the copy operation the parent task may actually have active mappings. And if those mappings conflict with the requirements that the copy operation needs then something has to give. Note that the copy operation cannot wait on the parent to unmap the conflicting regions because the parent in turn is waiting on the copy operation to complete. This circular deadlock is prevented by the runtime by transparently unmapping the conflicting regions.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PhysicalRegion</span><span class="o">&gt;</span> <span class="n">unmapped_regions</span><span class="p">;</span>
  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">find_conflicting_regions</span><span class="p">(</span><span class="n">copy_op</span><span class="p">,</span> <span class="n">unmapped_regions</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unmapped_regions</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// Unmap any regions which are conflicting</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">unmapped_regions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">unmapped_regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">unmap_region</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">add_to_dependence_queue</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">copy_op</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>
<p>The unmap operations are also added to the pipeline. Note that they are added before <em>add</em>to<em>dependence</em>queue_ for this copy operation, so the unmappings will complete first. If any regions were unmapped then these mappings must be restored before the parent resumes because it expects them to be present. This is done by looping over the regions that were unmapped and creating new inline mappings.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="c1">// Remap any regions which we unmapped</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unmapped_regions</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">mapped_events</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">unmapped_regions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">MapOp</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">get_available_map_op</span><span class="p">();</span>
      <span class="n">op</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">unmapped_regions</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
      <span class="n">mapped_events</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">get_completion_event</span><span class="p">());</span>
      <span class="n">add_to_dependence_queue</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Wait for all the re-mapping operations to complete</span>
    <span class="n">Event</span> <span class="n">mapped_event</span> <span class="o">=</span> <span class="n">Event</span><span class="o">::</span><span class="n">merge_events</span><span class="p">(</span><span class="n">mapped_events</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapped_event</span><span class="p">.</span><span class="n">has_triggered</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">pre_wait</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
      <span class="n">mapped_event</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
      <span class="n">post_wait</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>
<p>Notice that as we create the inline mappings that we take all the completion events and combine them. We&#39;ll wait until the inline mappings finishes before continuing. While idle, other tasks might be scheduled onto the CPU. Note that generally applications should try to avoid situations in which the runtime is automatically performing these unmap and remap operations because an application is often in a better position to reduce such conflicts. The runtime still ensures correctness, but the latency associated with waiting for the inline mappings to be recreated cannot be hidden.</p>

<p>The first stop for an operation in the pipeline is dependence analysis. At a high-level dependence analysis for a copy operation is similar to the inline mapping we saw in the last class. Note that here we loop through all of the source requirements and perform analysis on each one. Not shown here is a second loop over all of the destination regions. Next let&#39;s focus on <code>register_predicate_dependence</code>, which is an aspect of speculative operations that we haven&#39;t seen yet.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">CopyOp</span><span class="o">::</span><span class="n">trigger_dependence_analysis</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">begin_dependence_analysis</span><span class="p">();</span>
  <span class="c1">// Register a dependence on our predicate</span>
  <span class="n">register_predicate_dependence</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">src_requirements</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">forest</span><span class="o">-&gt;</span><span class="n">perform_dependence_analysis</span><span class="p">(</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">get_context</span><span class="p">(),</span>
                 <span class="k">this</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">src_requirements</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">src_privilege_paths</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
      <span class="p">}</span>
<span class="p">...</span>
      <span class="n">end_dependence_analysis</span><span class="p">();</span>
</code></pre></div>
<p>Recall that the copy operation is an instance of a speculative operation:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">CopyOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Copy</span><span class="p">,</span> <span class="k">public</span> <span class="n">SpeculativeOp</span> <span class="p">{</span>
</code></pre></div>
<p>What this means is that the operation completes or doesn&#39;t complete based on a predicate value. The predicate value is set when we initialized the copy operation (note the last parameter to <code>initialize_speculation</code>):</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">CopyOp</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">SingleTask</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">CopyLauncher</span> <span class="o">&amp;</span><span class="n">launcher</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">check_privileges</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">parent_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
  <span class="n">parent_task</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
  <span class="n">initialize_speculation</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*track*/</span><span class="p">,</span> <span class="n">Event</span><span class="o">::</span><span class="n">NO_EVENT</span><span class="p">,</span>
        <span class="n">launcher</span><span class="p">.</span><span class="n">src_requirements</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">launcher</span><span class="p">.</span><span class="n">dst_requirements</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> 
        <span class="n">launcher</span><span class="p">.</span><span class="n">predicate</span><span class="p">);</span>
</code></pre></div>
<p>The <code>register_predicate_dependence</code> is a call in <code>CopyOp::trigger_dependence_analysis</code> is part the abstract base class, a <code>SpeculativeOp</code>. The predicate for this <code>CopyOp</code> at this point is already in the pipeline (such as the <code>Future</code> from a previously launched task). What this call does is to attach to that predicate as a dependence so that the dependency becomes part of the overall dependency analysis.</p>

<p>Normally after dependence analysis an operation is ready to map. However, this may not always be true for speculative operations. One of the things that can happen is that the predicate that is being speculated on tells us that it has resolved its value. The interface for this is in the speculative operation class.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">SpeculativeOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">PredicateWaiter</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">trigger_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="c1">// Call this method for inheriting classes </span>
    <span class="c1">// to indicate when they should map</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">speculate</span><span class="p">(</span><span class="kt">bool</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">resolve_true</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">resolve_false</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
<span class="p">...</span>
</code></pre></div>
<p>Note that <code>speculate</code>, <code>resolve_true</code>, and <code>resolve_false</code> are implemented by the <code>CopyOp</code>. The <code>SpeculativeOp</code> class takes care of all the plumbing and logic that is shared among operations that are speculative.</p>

<p>How does mapping occur for the <code>CopyOp</code> (related: <code>CopyOp</code> doesn&#39;t implement <code>trigger_mapping</code>)? Note that <code>trigger_mapping</code> is called once dependencies are resolved. Instead of it being handled by the <code>CopyOp</code>, the speculative operation will take care of things in <code>SpeculativeOp::trigger_mapping</code>, and communicate the results to the sub-class via the <code>resolve_true</code>, <code>resolve_false</code>, and <code>speculate</code> pure virtual methods. The first thing we do is handle some special cases where there is no predicate, in which case we just examine whatever the state of speculation is and call down into the sub-class:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">SpeculativeOp</span><span class="o">::</span><span class="n">trigger_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Quick out</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">predicate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">speculation_state</span> <span class="o">==</span> <span class="n">RESOLVE_TRUE_STATE</span><span class="p">)</span>
      <span class="n">resolve_true</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="nf">resolve_false</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>
<p>But we might have a real predicate, and we may not have resolved its value yet. So we register ourselves as a waiter on the predicate. Several things happen here. We may try to speculate on the value (see discussion below), and then depending on the outcome of more logic in this function that has been omitted, we trigger the result of the predicate with the sub-class.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="p">...</span>
  <span class="kt">bool</span> <span class="n">value</span><span class="p">,</span> <span class="n">speculated</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">predicate</span><span class="o">-&gt;</span><span class="n">register_waiter</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">get_generation</span><span class="p">(),</span> <span class="n">value</span><span class="p">);</span>
  <span class="c1">// Now that we&#39;ve attempted to register ourselves with the</span>
  <span class="c1">// predicate we can remove the predicate reference</span>
  <span class="n">predicate</span><span class="o">-&gt;</span><span class="n">remove_predicate_reference</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">)</span>
    <span class="n">speculated</span> <span class="o">=</span> <span class="n">speculate</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">continue_true</span><span class="p">)</span>
    <span class="n">resolve_true</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">continue_false</span><span class="p">)</span>
    <span class="n">resolve_false</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">need_resolution</span><span class="p">)</span>
    <span class="n">resolve_speculation</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>
<p>The mapper can be asked to speculate on the value, as mappers may be able to make a good guess. The example cited in the class is that of conjugate gradient in which convergence is a predicate. Since convergence occurs at the end, it&#39;s safe to guess that we haven&#39;t yet converged at any particular moment. When we speculate true, we start running the operation even though we don&#39;t yet know the final value. Another valid scenario is that the mapper has no guess. In this case the mapper can request that no speculation occur, and instead just block until the value is known.</p>

<p>So if all this is hidden from the copy operation, how does it actually start executing? 
It has implementations of <code>speculate</code>, <code>resolve_true</code>, and <code>resolve_false</code>. These were called by the <code>SpeculativeOp</code> class when it figured out what&#39;s going on with the speculation and the predicate.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">CopyOp</span><span class="o">::</span><span class="n">resolve_true</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Put this on the queue of stuff to do</span>
  <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">add_to_local_queue</span><span class="p">(</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">get_executing_processor</span><span class="p">(),</span>
             <span class="k">this</span><span class="p">,</span> <span class="nb">false</span><span class="cm">/*prev fail*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CopyOp</span><span class="o">::</span><span class="n">resolve_false</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Mark that this operation has completed both</span>
  <span class="c1">// execution and mapping indicating that we are done</span>
  <span class="c1">// Do it in this order to avoid calling &#39;execute_trigger&#39;</span>
  <span class="n">complete_execution</span><span class="p">();</span>
  <span class="n">complete_mapping</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>Now that&#39;s cool. If true we add ourselves to the queue for execution, and the predicate was false then we just clean up and abort.</p>

<p>Execution of the copy operation in <code>CopyOp::trigger_execution</code> is similar to inline mapping in many respects. We premap all of the sources and all the destinations. The mapper is consulted about what memories should be preferred, and then mapping is attempted. Failures might occur and the operation can report this and be restarted later. After all the regions have mapped and are ready to go, the <code>copy_across</code> method on the region forest objects are invoked, which is a low-level operation that performs the actual copying.</p>

<p>As we call <code>copy_across</code> we collect the completion events:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">src_requirements</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Now issue the copies from source to destination</span>
  <span class="n">copy_complete_events</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">forest</span><span class="o">-&gt;</span><span class="n">copy_across</span><span class="p">(</span><span class="n">src_contexts</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
           <span class="n">dst_contexts</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">src_requirements</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
           <span class="n">dst_requirements</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">src_ref</span><span class="p">,</span> <span class="n">dst_ref</span><span class="p">,</span> <span class="n">sync_precondition</span><span class="p">));</span>

  <span class="p">...</span>

  <span class="c1">// Launch the complete task if necessary </span>
  <span class="n">Event</span> <span class="n">copy_complete_event</span> <span class="o">=</span> <span class="n">Event</span><span class="o">::</span><span class="n">merge_events</span><span class="p">(</span><span class="n">copy_complete_events</span><span class="p">);</span>
</code></pre></div>
<p>Then we use the <code>copy_complete_event</code> that represents all of the issued copies, and check to see if the work is done. If it isn&#39;t, we will spin up a new task predicated on the copy event that will eventually finish execution for us:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">// Handle the case for marking when the copy completes</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_complete_event</span><span class="p">.</span><span class="n">has_triggered</span><span class="p">())</span>
<span class="p">{</span>
  <span class="c1">// Issue a deferred trigger on our completion event</span>
  <span class="c1">// and mark that we are no longer responsible for</span>
  <span class="c1">// triggering our completion event.</span>
  <span class="n">completion_event</span><span class="p">.</span><span class="n">trigger</span><span class="p">(</span><span class="n">copy_complete_event</span><span class="p">);</span>
  <span class="n">need_completion_trigger</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">DeferredCompleteArgs</span> <span class="n">deferred_complete_args</span><span class="p">;</span>
  <span class="n">deferred_complete_args</span><span class="p">.</span><span class="n">hlr_id</span> <span class="o">=</span> <span class="n">HLR_DEFERRED_COMPLETE_ID</span><span class="p">;</span>
  <span class="n">deferred_complete_args</span><span class="p">.</span><span class="n">proxy_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="n">util</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">HLR_TASK_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deferred_complete_args</span><span class="p">,</span> 
         <span class="k">sizeof</span><span class="p">(</span><span class="n">deferred_complete_args</span><span class="p">),</span> <span class="n">copy_complete_event</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>
<p>The deferred task that runs will eventually call <code>deferred_complete</code> on this instance of the <code>CopyOp</code> operation (notice the <code>proxy_this = this</code> line). The <code>deferred_complete</code> method for the <code>CopyOp</code> will turn around and call <code>complete_execution</code>. Boom, done.</p>

<h2>Predicate Operations</h2>

<p>Predicates are of type <code>Predicate</code>:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Predicate</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Predicate</span> <span class="n">TRUE_PRED</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Predicate</span> <span class="n">FALSE_PRED</span><span class="p">;</span>
</code></pre></div>
<p>Predicates can be created from boolean futures:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">Predicate</span> <span class="nf">create_predicate</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Future</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
</code></pre></div>
<p>A non-boolean future can be created using the deferred task execution model by launching a task to evaluate the future and then return a boolean future. Predicates can also be created by combining predicates using logic operators:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">Predicate</span> <span class="nf">predicate_not</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Predicate</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
<span class="n">Predicate</span> <span class="nf">predicate_and</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Predicate</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Predicate</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">);</span>
<span class="n">Predicate</span> <span class="nf">predicate_or</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Predicate</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Predicate</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>
<p>All of these are themselves operations that are shuffled through the execution pipeline.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">Predicate</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">create_predicate</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Future</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">FuturePredOp</span> <span class="o">*</span><span class="n">pred_op</span> <span class="o">=</span> <span class="n">get_available_future_pred_op</span><span class="p">();</span>
  <span class="c1">// Hold a reference before initialization</span>
  <span class="n">Predicate</span> <span class="nf">result</span><span class="p">(</span><span class="n">pred_op</span><span class="p">);</span>
  <span class="n">pred_op</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">add_to_dependence_queue</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">pred_op</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<p>That&#39;s it for operations for today.</p>

  </article>

  <section id="disqus_thread"></section>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'noahdesugithubcom'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">makedist</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>makedist</li>
          <li><a href="mailto:noahwatkins@gmail.com">noahwatkins@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/noahdesu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/noahdesu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Notes on programming, research, and other interests.
</p>
      </div>
    </div>

  </div>

</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37966177-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>

</html>
