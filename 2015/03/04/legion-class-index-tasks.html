<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Legion Runtime Class #11: Index Space Tasks</title>
  <meta name="description" content="Overview">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://noahdesu.github.io/2015/03/04/legion-class-index-tasks.html">
  <link rel="alternate" type="application/rss+xml" title="makedist" href="http://noahdesu.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">makedist</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="/legion.html">Legion</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Legion Runtime Class #11: Index Space Tasks</h1>
    <p class="post-meta">Mar 4, 2015
    </p>
    <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="noahdesu">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </header>

  <article class="post-content">
    <h1>Overview</h1>

<p>Today we&#39;ll take a look at index space tasks.</p>

<h1>About Legion Runtime Class</h1>

<p>These notes are closely based on the set
of <a href="http://www.youtube.com/playlist?list=PLUNK9XcztK7xjXfppL9hIpVv2ukp7A4tG">Legion Runtime
Class</a>
videos produced by the <a href="http://legion.stanford.edu">Legion</a> developers. They are my own notes and code walks, and any
errors or things that are just plain wrong represent my own mistakes.</p>

<p>Today&#39;s notes are based on the following video:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/aa9Ouc5XDl0?list=PLUNK9XcztK7xjXfppL9hIpVv2ukp7A4tG" frameborder="0" allowfullscreen></iframe>

<h1>Index Task Launch</h1>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">FutureMap</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">execute_index_space</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> 
    <span class="k">const</span> <span class="n">IndexLauncher</span> <span class="o">&amp;</span><span class="n">launcher</span><span class="p">)</span>

<span class="n">Future</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">execute_index_space</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> 
    <span class="k">const</span> <span class="n">IndexLauncher</span> <span class="o">&amp;</span><span class="n">launcher</span><span class="p">,</span> <span class="n">ReductionOpID</span> <span class="n">redop</span><span class="p">)</span>
</code></pre></div>
<p>The first version returns a <code>FutureMap</code> which stores the results from each task defined by the index space, that is a result per point in the launch domain. The second form applies a reduction operator to all the results and returns a single reduced future.</p>

<p>When an index task is launched this is the common thing that happens (logic related to the task&#39;s speculation have been removed; recall that tasks are speculative operations):</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">FutureMap</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">execute_index_space</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">IndexLauncher</span> <span class="o">&amp;</span><span class="n">launcher</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="n">IndexTask</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_available_index_task</span><span class="p">();</span>
  <span class="n">FutureMap</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">initialize_task</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">launcher</span><span class="p">,</span>
      <span class="nb">false</span><span class="cm">/*check privileges*/</span><span class="p">);</span>

  <span class="n">execute_task_launch</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>When an index space task is launched it starts off like any other task via <code>execute_task_launch</code>, and then differs by how it is treated as it progresses through the operational pipeline. The first stop is <code>trigger_dependence_analysis</code>.</p>

<p>Recall that dependence analysis is a serial operation that can be expensive. In order to avoid performing dependence analysis on all tasks represented by the index task launch domain, the runtime takes advantage of the fact that region requirements on the index space task are upper bound requirements on all sub-tasks that will be launched.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">IndexTask</span><span class="o">::</span><span class="n">trigger_dependence_analysis</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">begin_dependence_analysis</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="n">register_predicate_dependence</span><span class="p">();</span>
  <span class="n">RegionTreeContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">get_context</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">regions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">forest</span><span class="o">-&gt;</span><span class="n">perform_dependence_analysis</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> 
        <span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">privilege_paths</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">end_dependence_analysis</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>Above we see that dependence analysis occurs on each of the regions, rather than all of the tasks that will be launched as a result of executing the index task. Specifically, the runtime will try its best to avoid enumerating all of the tasks in the launch domain until the last possible moment.</p>

<p>Avoiding the enumeration of all points also extends to the mapper interface. That is, instead of mapping each point task separately, the mapper can map the entire index space at once. To see how this works lets look at <code>MultiTask::trigger_execution</code>. Note that the <code>MultiTask</code> is the parent class of both <code>IndexTask</code> and <code>SliceTask</code>. We&#39;ve been looking at the index task so far, and we&#39;ll see what a slice task is momentarily, but note that both share the same implementation of <code>trigger_execution</code>.</p>

<p>Like last time, we&#39;ll skip the remote case first and look at the initial case where the task is being launched and <code>trigger_execution</code> will be occurring on a local node.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">MultiTask</span><span class="o">::</span><span class="n">trigger_execution</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="c1">//--------------------------------------------------------------------------</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_remote</span><span class="p">())</span>
  <span class="p">{</span>
  <span class="p">...</span>
</code></pre></div>
<p>Here we are at the non-remote case. First we check if the task has pre-mapped, and if it has then we are good (fall through), otherwise pre-mapping needs to execute. Pre-mapping failure will return false to the caller and the task will be restarted later. So, once the task has been pre-mapped we first check if is locally mapped. When thinking about individual tasks it makes sense to map a task locally, but for an index space task, mapping locally requires enumerating all tasks locally and run them. In most cases we try to avoid this, and the code for that case below has been trimmed out.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">  else
  {
    // Not remote, make sure it is premapped
    if (is_premapped() || premap_task())
    {
      if (is_locally_mapped())
      {
        ...
      }
      else
      {
</code></pre></div>
<p>Here we are. We are not mapped locally, so the first thing we attempt to do is distribute the task (that is, the mapper might choose to send the task elsewhere). Recall that <code>distribute_task</code> will return true if the task should run locally.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">        <span class="k">if</span> <span class="p">(</span><span class="n">distribute_task</span><span class="p">())</span>
        <span class="p">{</span>
</code></pre></div>
<p>The runtime maintains the invariant that an index task never leaves the node that it was created on. The version of <code>MultiTask</code> that can move around in the system is the <code>SliceTask</code>. A slice task is effectively identical to an index task, but may represent a subset of the full domain represented by an index task.</p>

<p>So in <code>IndexTask::distribute_task</code> if we send the index task away, then we first clone it as a <code>SliceTask</code>. Since the entire index task is moving, the domain of the slice task will be the entire domain of the index task. Once the slice task arrives on the remote node it will be unpacked and enter the operational pipeline on the remote node as a slice task, but effectively an identical clone to the original index task.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">IndexTask</span><span class="o">::</span><span class="n">distribute_task</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sliced</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">target_proc</span> <span class="o">!=</span> <span class="n">current_proc</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="c1">// Make a slice copy and send it away</span>
    <span class="n">SliceTask</span> <span class="o">*</span><span class="n">clone</span> <span class="o">=</span> <span class="n">clone_as_slice_task</span><span class="p">(</span><span class="n">index_domain</span><span class="p">,</span> <span class="n">target_proc</span><span class="p">,</span>
      <span class="nb">true</span><span class="cm">/*needs slice*/</span><span class="p">,</span> <span class="n">spawn_task</span><span class="p">,</span> <span class="mi">1LL</span><span class="p">);</span>

    <span class="c1">// Before we do this we have to chain the all children mapped event</span>
    <span class="n">all_children_mapped</span><span class="p">.</span><span class="n">trigger</span><span class="p">(</span><span class="n">clone</span><span class="o">-&gt;</span><span class="n">get_children_mapped</span><span class="p">());</span>

    <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">send_task</span><span class="p">(</span><span class="n">target_proc</span><span class="p">,</span> <span class="n">clone</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// We have now been sent away</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Still local so we can be sliced</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Returning to <code>MultiTask::trigger_execution</code> we have now run <code>distribute_task</code> and we returned true in the case that the index task should be run locally. The next step is to see if the index space has been sliced. If it has not been sliced yet, then we call <code>slice_index_space</code>:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">          <span class="c1">// Still local try slicing, mapping, and launching</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">is_sliced</span><span class="p">())</span>
          <span class="p">{</span>
            <span class="n">success</span> <span class="o">=</span> <span class="n">map_and_launch</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="k">else</span>
            <span class="n">success</span> <span class="o">=</span> <span class="n">slice_index_space</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">// failed to premap</span>
      <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div>
<p>The method <code>MultiTask::slice_index_space</code> will communicate with the mapper to construct the set of slices that represent the decomposition of the index space into smaller <code>SliceTask</code> objects. First we set <code>sliced</code> to be <code>true</code> to indicate we&#39;ve already run this method, and <code>spawn_task</code> to false indicating that this task cannot be stolen (although the new slice tasks that will be created can be stolen). Finally we invoke the mapper to slice the domain of the index space task. The mapper will fill in the <code>splits</code> structure with a set of <code>DomainSplit</code> object:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">MultiTask</span><span class="o">::</span><span class="n">slice_index_space</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sliced</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">spawn_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// cannot steal something that has been sliced</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mapper</span><span class="o">::</span><span class="n">DomainSplit</span><span class="o">&gt;</span> <span class="n">splits</span><span class="p">;</span>
  <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">invoke_mapper_slice_domain</span><span class="p">(</span><span class="n">current_proc</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">splits</span><span class="p">);</span>
</code></pre></div>
<p>Next we create new <code>SliceTask</code> objects for each of the domain splits requested by the mapper. We loop over these splits and clone the index space as a slice task. This clone operation is effectively a 1-1 copy, except for the domain component. The domain component for the slice task will correspond to the current domain split.</p>

<p>All of the new slice tasks are collected in the <code>slices</code> data structure, and then the <code>trigger_slices</code> method is called.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">all_slices_mapped</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">splits</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">SliceTask</span> <span class="o">*</span><span class="n">slice</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">clone_as_slice_task</span><span class="p">(</span>
            <span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">proc</span><span class="p">,</span>
            <span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">recurse</span><span class="p">,</span>
            <span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">stealable</span><span class="p">,</span>
            <span class="n">splits</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">all_slices_mapped</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">slice</span><span class="o">-&gt;</span><span class="n">get_children_mapped</span><span class="p">());</span>
    <span class="n">slices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Trigger our all children mapped as being done when all</span>
  <span class="c1">// the slices have all their children mapped</span>
  <span class="n">all_children_mapped</span><span class="p">.</span><span class="n">trigger</span><span class="p">(</span><span class="n">Event</span><span class="o">::</span><span class="n">merge_events</span><span class="p">(</span><span class="n">all_slices_mapped</span><span class="p">));</span>

  <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">trigger_slices</span><span class="p">();</span>

  <span class="p">...</span>

  <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The <code>trigger_slices</code> method will start the launching of all of the newly created slice tasks. The <code>DeferredSlicer</code> object contains a method that takes the slices as a parameter and then immediately dumps them onto utility processors to extract as much parallelism as possible from this task launch.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">MultiTask</span><span class="o">::</span><span class="n">trigger_slices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">DeferredSlicer</span> <span class="n">slicer</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">slicer</span><span class="p">.</span><span class="n">trigger_slices</span><span class="p">(</span><span class="n">slices</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Notice below that the <code>slices</code> object that we filled in is looped over to launch each slice asynchronously:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">DeferredSlicer</span><span class="o">::</span><span class="n">trigger_slices</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">SliceTask</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">slices</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">wait_events</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="n">Processor</span> <span class="n">util_proc</span> <span class="o">=</span> <span class="n">owner</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">find_utility_group</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">SliceTask</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">DeferredSliceArgs</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">args</span><span class="p">.</span><span class="n">hlr_id</span> <span class="o">=</span> <span class="n">HLR_DEFERRED_SLICE_ID</span><span class="p">;</span>
    <span class="n">args</span><span class="p">.</span><span class="n">slicer</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> 
    <span class="p">{</span>
      <span class="n">args</span><span class="p">.</span><span class="n">slice</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
      <span class="n">it</span><span class="o">++</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">done</span> <span class="o">=</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> 
      <span class="n">Event</span> <span class="n">wait</span> <span class="o">=</span> <span class="n">util_proc</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">HLR_TASK_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">));</span> 
      <span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">.</span><span class="n">exists</span><span class="p">())</span>
        <span class="n">wait_events</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="p">...</span>
</code></pre></div>
<p>Eventually each slice task will make it through the operational pipeline again and return to <code>trigger_execution</code>. The slice task will return through <code>MultiTask::trigger_execution</code>. During the call <code>distribute_task</code> will be called and the task may be moved, and it may also be recursively decomposed, but eventually we&#39;ll make it to the point where the task should run locally and is sliced. In this case <code>map_and_launch</code> will be called:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">        <span class="k">if</span> <span class="p">(</span><span class="n">distribute_task</span><span class="p">())</span>
        <span class="p">{</span>
          <span class="c1">// Still local try slicing, mapping, and launching</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">is_sliced</span><span class="p">())</span>
          <span class="p">{</span>
            <span class="n">success</span> <span class="o">=</span> <span class="n">map_and_launch</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="k">else</span>
            <span class="n">success</span> <span class="o">=</span> <span class="n">slice_index_space</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>
<p>There are two variants of <code>map_and_launch</code>, one for index space tasks and one for slice tasks. The index space task version will be called when slice tasks fail to map in which case the failed slice tasks will be relaunched, so it is relatively simple. The <code>map_and_launch</code> version for slice tasks is where the good stuff is happening.</p>

<p>The first thing that happens is that we enumerate the points in the index space domain that this slice task manages. For each of the points a <code>PointTask</code> is created and mapped. Since slice tasks can fail and be restarted, we check to see if we can avoid re-enumerating the points:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">SliceTask</span><span class="o">::</span><span class="n">map_and_launch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">map_success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Mark that this task is no longer stealable.  Once we start</span>
  <span class="c1">// executing things onto a specific processor slices cannot move.</span>
  <span class="n">spawn_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// First enumerate all of our points if we haven&#39;t already done so</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">enumerate_points</span><span class="p">();</span>
</code></pre></div>
<p>First the mapper is queried to see what (if any) variant of this task should be used when launching the points. Then we iterate over the domain, clone the slice task into a new point task specialized on this particular point, and then add the new slice task to the set of point tasks tracked by this slice task.</p>

<p>Finally we record some metadata about how many of these tasks there are and what stage they are in. This is used for the slice task to manage execution through the pipeline by monitoring the state of its children.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">SliceTask</span><span class="o">::</span><span class="n">enumerate_points</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">invoke_mapper_select_variant</span><span class="p">(</span><span class="n">current_proc</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>

  <span class="c1">// Enumerate all the points</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">all_points_mapped</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Domain</span><span class="o">::</span><span class="n">DomainPointIterator</span> <span class="n">itr</span><span class="p">(</span><span class="n">index_domain</span><span class="p">);</span> <span class="n">itr</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">PointTask</span> <span class="o">*</span><span class="n">next_point</span> <span class="o">=</span> <span class="n">clone_as_point_task</span><span class="p">(</span><span class="n">itr</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
    <span class="n">all_points_mapped</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">next_point</span><span class="o">-&gt;</span><span class="n">get_children_mapped</span><span class="p">());</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next_point</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Trigger our all children mapped based on all the points being mapped</span>
  <span class="n">all_children_mapped</span><span class="p">.</span><span class="n">trigger</span><span class="p">(</span><span class="n">Event</span><span class="o">::</span><span class="n">merge_events</span><span class="p">(</span><span class="n">all_points_mapped</span><span class="p">));</span>

  <span class="n">mapping_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// Mark how many points we have</span>
  <span class="n">num_unmapped_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">num_uncomplete_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">num_uncommitted_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span> 
</code></pre></div>
<p>After the points are enumerated in <code>map_and_launch</code> the point tasks are mapped. Notice that the first thing that occurs is that a copy of the points structure we filled in when creating the point tasks is made on the stack. This is to address a race condition. When the last point task finishes it will clean up the parent slice task. However, this could actually happen before we even return from this function. Thus we need to keep a copy of state so that if this function is racing with the <code>SliceTask</code> cleanup that we are still seeing valid data. I&#39;m not a fan of this type of race condition. Perhaps this could be fixed with some dependency event chains??? Anyway... the <code>mapping_index</code> state variable is used to track the last point task that was launched to avoid duplicate work if we have to restart some point tasks that fail (we&#39;ll come back through this as part of that restart procedure).</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">SliceTask</span><span class="o">::</span><span class="n">map_and_launch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointTask</span><span class="o">*&gt;</span> <span class="n">local_points</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="n">mapping_index</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">mapping_index</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
    <span class="n">local_points</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="n">mapping_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointTask</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">local_points</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
      <span class="n">it</span> <span class="o">!=</span> <span class="n">local_points</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">PointTask</span> <span class="o">*</span><span class="n">next_point</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">point_success</span> <span class="o">=</span> <span class="n">next_point</span><span class="o">-&gt;</span><span class="n">perform_mapping</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">point_success</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">map_success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>    
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>

    <span class="p">...</span>
</code></pre></div>
<p>Mapping a point task is handled by <code>PointTask::perform_mapping</code>. Notice that it is relatively simple, and we&#39;ve even seen parts of it in past classes. In particular, the heart of this thing is <code>map_all_regions</code> which we previously explored.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">PointTask</span><span class="o">::</span><span class="n">perform_mapping</span><span class="p">(</span><span class="kt">bool</span> <span class="n">mapper_invoked</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">map_success</span> <span class="o">=</span> <span class="n">map_all_regions</span><span class="p">(</span><span class="n">target_proc</span><span class="p">,</span> 
            <span class="n">point_termination</span><span class="p">,</span> <span class="n">mapper_invoked</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">map_success</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">num_virtual_mappings</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="c1">// Tell our owner that we mapped</span>
    <span class="n">slice_owner</span><span class="o">-&gt;</span><span class="n">record_child_mapped</span><span class="p">();</span>

    <span class="c1">// Mark that we ourselves have mapped</span>
    <span class="n">complete_mapping</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">map_success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The remote case for <code>trigger_execution</code> is quite simple once we&#39;ve seen the local case:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">MultiTask</span><span class="o">::</span><span class="n">trigger_execution</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_remote</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="c1">// distribute, slice, then map/launch</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distribute_task</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="c1">// Still local</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">is_sliced</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_locally_mapped</span><span class="p">())</span>
        <span class="p">{</span>
          <span class="n">launch_task</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="c1">// Try mapping and launching</span>
          <span class="n">success</span> <span class="o">=</span> <span class="n">map_and_launch</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">slice_index_space</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="p">...</span>
</code></pre></div>
<p>Now let&#39;s take a look at the locally mapped case. The mapper in this case has asked the runtime to map the index task on the local node before trying to distribute (i.e. <code>is_locally_mapped</code> is true). Effectively what is happening is the slicing and enumeration prior to distributing versus slicing and distributing then enumerating (the previous cases we&#39;ve looked at):</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">        <span class="c1">// Not remote, make sure it is premapped</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_premapped</span><span class="p">()</span> <span class="o">||</span> <span class="n">premap_task</span><span class="p">())</span>
        <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">is_locally_mapped</span><span class="p">())</span>
          <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_sliced</span><span class="p">())</span>
            <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">must_epoch</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">register_must_epoch</span><span class="p">();</span>
              <span class="k">else</span>
              <span class="p">{</span>
                <span class="c1">// See if we&#39;re going to send it</span>
                <span class="c1">// remotely.  If so we need to do</span>
                <span class="c1">// the mapping now.  Otherwise we</span>
                <span class="c1">// can defer the mapping until we get</span>
                <span class="c1">// on the target processor.</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">is_local</span><span class="p">(</span><span class="n">target_proc</span><span class="p">))</span>
                <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="n">perform_mapping</span><span class="p">())</span>
                  <span class="p">{</span>
                    <span class="n">distribute_task</span><span class="p">();</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="c1">// failed to map</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
   <span class="p">...</span>
</code></pre></div>
  </article>

  <section id="disqus_thread"></section>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'noahdesugithubcom'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">makedist</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>makedist</li>
          <li><a href="mailto:noahwatkins@gmail.com">noahwatkins@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/noahdesu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/noahdesu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Notes on programming, research, and other interests.
</p>
      </div>
    </div>

  </div>

</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37966177-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>

</html>
