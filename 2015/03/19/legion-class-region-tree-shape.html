<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Legion Runtime Class #13: Region Tree Shape</title>
  <meta name="description" content="Overview">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://noahdesu.github.io/2015/03/19/legion-class-region-tree-shape.html">
  <link rel="alternate" type="application/rss+xml" title="makedist" href="http://noahdesu.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">makedist</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="/legion.html">Legion</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Legion Runtime Class #13: Region Tree Shape</h1>
    <p class="post-meta">Mar 19, 2015
    </p>
    <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="noahdesu">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </header>

  <article class="post-content">
    <h1>Overview</h1>

<p>In previous classes we&#39;ve covered a lot ground related to the high-level runtime including the operational pipeline and how tasks work. A lot of the interesting things that happen in Legion are part of the region tree, which we will start to look at today. The region tree forest is a data structure that tracks all of the region data in an Legion program.</p>

<h1>About Legion Runtime Class</h1>

<p>These notes are closely based on the set
of <a href="http://www.youtube.com/playlist?list=PLUNK9XcztK7xjXfppL9hIpVv2ukp7A4tG">Legion Runtime
Class</a>
videos produced by the <a href="http://legion.stanford.edu">Legion</a> developers. They are my own notes and code walks, and any
errors or things that are just plain wrong represent my own mistakes.</p>

<p>Today&#39;s notes are based on the following video:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/akz4ND0x4ok?list=PLUNK9XcztK7xjXfppL9hIpVv2ukp7A4tG" frameborder="0" allowfullscreen></iframe>

<h1>Region Tree Forest</h1>

<p>All of the region tree bits are located in <code>region_tree.cc</code> and <code>region_tree.h</code>. The <code>RegionTreeForest</code> is defined in <code>region_tree.h</code>, and provides an interface between the rest of Legion and the region data structures.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">class</span> <span class="nc">RegionTreeForest</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">RegionTreeForest</span><span class="p">(</span><span class="n">Runtime</span> <span class="o">*</span><span class="n">rt</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>
<p>The forest structure is effectively a singleton as there is exactly one of the forests created for each instance of the high-level runtime (which is also a singleton):</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">class</span> <span class="nc">Runtime</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="n">RegionTreeForest</span> <span class="o">*</span><span class="k">const</span> <span class="n">forest</span><span class="p">;</span>
</code></pre></div>
<p>The <code>forest</code> field is set when the runtime is created:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">Runtime</span><span class="o">::</span><span class="n">Runtime</span><span class="p">(</span><span class="n">Machine</span> <span class="n">m</span><span class="p">,</span> <span class="n">AddressSpaceID</span> <span class="n">unique</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">locals</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">local_utilities</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">AddressSpaceID</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">address_spaces</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Processor</span><span class="p">,</span><span class="n">AddressSpaceID</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">processor_spaces</span><span class="p">,</span>
                     <span class="n">Processor</span> <span class="n">cleanup</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">gc</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">message</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">high_level</span><span class="p">(</span><span class="k">new</span> <span class="n">HighLevelRuntime</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span> <span class="n">machine</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> 
        <span class="n">address_space</span><span class="p">(</span><span class="n">unique</span><span class="p">),</span> <span class="n">runtime_stride</span><span class="p">(</span><span class="n">address_spaces</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span>
        <span class="n">forest</span><span class="p">(</span><span class="k">new</span> <span class="n">RegionTreeForest</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span> <span class="n">outstanding_top_level_tasks</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
</code></pre></div>
<p>The interface of the <code>RegionTreeForest</code> is divided by category. For instance there are a set of interfaces for dealing with index partitions and index spaces:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">class</span> <span class="nc">RegionTreeForest</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">IndexPartition</span> <span class="n">get_index_partition</span><span class="p">(</span><span class="n">IndexSpace</span> <span class="n">parent</span><span class="p">,</span> <span class="n">Color</span> <span class="n">color</span><span class="p">);</span>
      <span class="n">IndexSpace</span> <span class="nf">get_index_subspace</span><span class="p">(</span><span class="n">IndexPartition</span> <span class="n">parent</span><span class="p">,</span> <span class="n">Color</span> <span class="n">color</span><span class="p">);</span>
      <span class="kt">bool</span> <span class="nf">has_multiple_domains</span><span class="p">(</span><span class="n">IndexSpace</span> <span class="n">handle</span><span class="p">);</span>
      <span class="n">Domain</span> <span class="nf">get_index_space_domain</span><span class="p">(</span><span class="n">IndexSpace</span> <span class="n">handle</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>
<p>As well as fields, logical regions, and logical and physical dependence analysis, among other things:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">create_field_space</span><span class="p">(</span><span class="n">FieldSpace</span> <span class="n">handle</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">destroy_field_space</span><span class="p">(</span><span class="n">FieldSpace</span> <span class="n">handle</span><span class="p">,</span> <span class="n">AddressSpaceID</span> <span class="n">source</span><span class="p">);</span>
      <span class="kt">bool</span> <span class="nf">allocate_field</span><span class="p">(</span><span class="n">FieldSpace</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">field_size</span><span class="p">,</span> 
                          <span class="n">FieldID</span> <span class="n">fid</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">local</span><span class="p">);</span>
      <span class="p">...</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">LogicalPartition</span> <span class="n">get_logical_partition</span><span class="p">(</span><span class="n">LogicalRegion</span> <span class="n">parent</span><span class="p">,</span> 
                                             <span class="n">IndexPartition</span> <span class="n">handle</span><span class="p">);</span>
      <span class="n">LogicalPartition</span> <span class="nf">get_logical_partition_by_color</span><span class="p">(</span>
                                  <span class="n">LogicalRegion</span> <span class="n">parent</span><span class="p">,</span> <span class="n">Color</span> <span class="n">color</span><span class="p">);</span>
      <span class="p">...</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="c1">// Logical analysis methods</span>
      <span class="kt">void</span> <span class="n">perform_dependence_analysis</span><span class="p">(</span><span class="n">RegionTreeContext</span> <span class="n">ctx</span><span class="p">,</span> 
                                       <span class="n">Operation</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span>
                                       <span class="n">RegionRequirement</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span>
                                       <span class="n">RegionTreePath</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">perform_fence_analysis</span><span class="p">(</span><span class="n">RegionTreeContext</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">Operation</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span>
      <span class="p">...</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="c1">// Physical analysis methods</span>
      <span class="kt">bool</span> <span class="n">premap_physical_region</span><span class="p">(</span><span class="n">RegionTreeContext</span> <span class="n">ctx</span><span class="p">,</span>
                                  <span class="n">RegionTreePath</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span>
                                  <span class="n">RegionRequirement</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span>
                                  <span class="n">Mappable</span> <span class="o">*</span><span class="n">mappable</span><span class="p">,</span>
                                  <span class="n">SingleTask</span> <span class="o">*</span><span class="n">parent_ctx</span><span class="p">,</span>
                                  <span class="n">Processor</span> <span class="n">local_proc</span>
                                  <span class="p">);</span>
      <span class="p">...</span>
</code></pre></div>
<h1>Tree Mutation</h1>

<p>Let&#39;s create an index space and see what happens. We&#39;ll call the version that creates an unstructured index space. First we get a handle for the index space, and then we immediately ask the forest to create the space for us.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">IndexSpace</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">create_index_space</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">max_num_elmts</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">IndexSpace</span> <span class="n">space</span> <span class="o">=</span> <span class="n">IndexSpace</span><span class="o">::</span><span class="n">create_index_space</span><span class="p">(</span><span class="n">max_num_elmts</span><span class="p">);</span>
      <span class="n">forest</span><span class="o">-&gt;</span><span class="n">create_index_space</span><span class="p">(</span><span class="n">Domain</span><span class="p">(</span><span class="n">space</span><span class="p">));</span>
      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">register_index_space_creation</span><span class="p">(</span><span class="n">space</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">space</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>Next the forest creates a node to represent the root (no parent) of a new index tree. The <code>create_node</code> method is overloaded based on the type of nodes we are creating.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="kt">void</span> <span class="n">RegionTreeForest</span><span class="o">::</span><span class="n">create_index_space</span><span class="p">(</span><span class="k">const</span> <span class="n">Domain</span> <span class="o">&amp;</span><span class="n">domain</span><span class="p">)</span> 
    <span class="p">{</span>
      <span class="n">create_node</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="nb">NULL</span><span class="cm">/*parent*/</span><span class="p">,</span> <span class="mi">0</span><span class="cm">/*color*/</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>There are several different versions of <code>create_node</code> defined:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">public</span><span class="o">:</span>
      <span class="n">IndexSpaceNode</span><span class="o">*</span> <span class="n">create_node</span><span class="p">(</span><span class="n">Domain</span> <span class="n">d</span><span class="p">,</span> <span class="n">IndexPartNode</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span> <span class="n">Color</span> <span class="n">c</span><span class="p">);</span>
      <span class="n">IndexPartNode</span><span class="o">*</span>  <span class="nf">create_node</span><span class="p">(</span><span class="n">IndexPartition</span> <span class="n">p</span><span class="p">,</span> <span class="n">IndexSpaceNode</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
                                 <span class="n">Color</span> <span class="n">c</span><span class="p">,</span> <span class="n">Domain</span> <span class="n">color_space</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">disjoint</span><span class="p">);</span>
      <span class="n">FieldSpaceNode</span><span class="o">*</span> <span class="nf">create_node</span><span class="p">(</span><span class="n">FieldSpace</span> <span class="n">space</span><span class="p">);</span>
      <span class="n">RegionNode</span><span class="o">*</span>     <span class="nf">create_node</span><span class="p">(</span><span class="n">LogicalRegion</span> <span class="n">r</span><span class="p">,</span> <span class="n">PartitionNode</span> <span class="o">*</span><span class="n">par</span><span class="p">);</span>
      <span class="n">PartitionNode</span><span class="o">*</span>  <span class="nf">create_node</span><span class="p">(</span><span class="n">LogicalPartition</span> <span class="n">p</span><span class="p">,</span> <span class="n">RegionNode</span> <span class="o">*</span><span class="n">par</span><span class="p">);</span>
</code></pre></div>
<p>We&#39;ll focus here on the one that creates an <code>IndexSpaceNode</code>. First we create a new node, and the grab the lookup lock which protects the <code>index_nodes</code> structure. This structure is simply a map from index spaces to index space nodes in the forest. With tasks and data moving around in a system its possible for two requests to create the same index space occur. In this case we delete the node we created and return the one already in the tree. When there is a parent, we record that too.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">IndexSpaceNode</span><span class="o">*</span> <span class="n">RegionTreeForest</span><span class="o">::</span><span class="n">create_node</span><span class="p">(</span><span class="n">Domain</span> <span class="n">d</span><span class="p">,</span> 
                                                  <span class="n">IndexPartNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
                                                  <span class="n">Color</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">IndexSpaceNode</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IndexSpaceNode</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="n">IndexSpace</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">get_index_space</span><span class="p">();</span>
      <span class="c1">// Check to see if someone else has already made it</span>
      <span class="p">{</span>
        <span class="c1">// Hold the lookup lock while modifying the lookup table</span>
        <span class="n">AutoLock</span> <span class="n">l_lock</span><span class="p">(</span><span class="n">lookup_lock</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">IndexSpace</span><span class="p">,</span><span class="n">IndexSpaceNode</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span>
          <span class="n">index_nodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">index_nodes</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="p">{</span>
          <span class="k">delete</span> <span class="n">result</span><span class="p">;</span>
          <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">index_nodes</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">parent</span><span class="o">-&gt;</span><span class="n">add_child</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>Note that unlike other operations we have seen that are deferred, these modifications are done immediately. The reason is that Legion applications frequently create an index space and then immediately start partitioning it, or doing other things. So delaying their creation would only add latency in most cases.</p>

<h1>Index Partition</h1>

<p>Creating an index partition is more complex. The method takes the index space that is being partitioned (the parent), a coloring that maps colors to points, and a flag indicating if the partitioning is disjoint. First we get a unique identifier for this partition.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">IndexPartition</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">create_index_partition</span><span class="p">(</span>
                                          <span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">IndexSpace</span> <span class="n">parent</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">Coloring</span> <span class="o">&amp;</span><span class="n">coloring</span><span class="p">,</span>
                                          <span class="kt">bool</span> <span class="n">disjoint</span><span class="p">,</span>
                                          <span class="kt">int</span> <span class="n">part_color</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">IndexPartition</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">get_unique_partition_id</span><span class="p">();</span>
</code></pre></div>
<p>Next we toss an error if the coloring is empty!</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">      <span class="k">if</span> <span class="p">(</span><span class="n">coloring</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="n">log_run</span><span class="p">(</span><span class="n">LEVEL_ERROR</span><span class="p">,</span><span class="s">&quot;Attempt to create index partition with no &quot;</span>
                            <span class="s">&quot;colors in task %s (ID %lld). Index partitions &quot;</span>
                            <span class="s">&quot;must have at least one color.&quot;</span><span class="p">,</span>
                            <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">variants</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">get_unique_task_id</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">ERROR_EMPTY_INDEX_PARTITION</span><span class="p">);</span>
      <span class="p">}</span>
</code></pre></div>
<p>Then we get to the good stuff. First we create a structure to represent the range of the color space. At a high-level the remainder of this function creates a new index space for each partition, and then creates a new index space partition with all the newly created index spaces as children.</p>

<p>The for loop that iterates over each color creates a new <code>ElementMask</code> for each color. An element mask is a data structure that is efficient in marking which pointers in a space have been allocated.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">      <span class="n">Point</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">coloring</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
      <span class="n">Point</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">upper_bound</span><span class="p">(</span><span class="n">coloring</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
      <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">color_range</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span><span class="n">upper_bound</span><span class="p">);</span>
      <span class="n">Domain</span> <span class="n">color_space</span> <span class="o">=</span> <span class="n">Domain</span><span class="o">::</span><span class="n">from_rect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">color_range</span><span class="p">);</span>
      <span class="c1">// Perform the coloring by iterating over all the colors in the</span>
      <span class="c1">// range.  For unspecified colors there is nothing wrong with</span>
      <span class="c1">// making empty index spaces.  We do this so we can save the</span>
      <span class="c1">// color space as a dense 1D domain.</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span><span class="n">Domain</span><span class="o">&gt;</span> <span class="n">new_index_spaces</span><span class="p">;</span> 
      <span class="k">for</span> <span class="p">(</span><span class="n">GenericPointInRectIterator</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">pir</span><span class="p">(</span><span class="n">color_range</span><span class="p">);</span> <span class="n">pir</span><span class="p">;</span> <span class="n">pir</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">LowLevel</span><span class="o">::</span><span class="n">ElementMask</span> 
                    <span class="n">child_mask</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">get_valid_mask</span><span class="p">().</span><span class="n">get_num_elmts</span><span class="p">());</span>
        <span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pir</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span><span class="n">ColoredPoints</span><span class="o">&lt;</span><span class="kt">ptr_t</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">finder</span> <span class="o">=</span> 
          <span class="n">coloring</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="c1">// If we had a coloring provided, then fill in all the elements</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">finder</span> <span class="o">!=</span> <span class="n">coloring</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="p">{</span>
          <span class="k">const</span> <span class="n">ColoredPoints</span><span class="o">&lt;</span><span class="kt">ptr_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pcoloring</span> <span class="o">=</span> <span class="n">finder</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">ptr_t</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">pcoloring</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
                <span class="n">it</span> <span class="o">!=</span> <span class="n">pcoloring</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">child_mask</span><span class="p">.</span><span class="n">enable</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">ptr_t</span><span class="p">,</span><span class="kt">ptr_t</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> 
                <span class="n">pcoloring</span><span class="p">.</span><span class="n">ranges</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">pcoloring</span><span class="p">.</span><span class="n">ranges</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">child_mask</span><span class="p">.</span><span class="n">enable</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>
<p>At the end of each loop iteration we create the new index space and record it.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">        <span class="c1">// Now make the index space and save the information</span>
        <span class="n">IndexSpace</span> <span class="n">child_space</span> <span class="o">=</span> 
          <span class="n">IndexSpace</span><span class="o">::</span><span class="n">create_index_space</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child_mask</span><span class="p">);</span>
        <span class="n">new_index_spaces</span><span class="p">[</span><span class="n">finder</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">(</span><span class="n">child_space</span><span class="p">);</span>
      <span class="p">}</span>
</code></pre></div>
<p>And finally we create the index partition with the new index spaces as children:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">      <span class="n">forest</span><span class="o">-&gt;</span><span class="n">create_index_partition</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">disjoint</span><span class="p">,</span>
                                 <span class="n">part_color</span><span class="p">,</span> <span class="n">new_index_spaces</span><span class="p">,</span> <span class="n">color_space</span><span class="p">);</span>

      <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>The forest then does its magic. It looks up the index space corresponding to the parent. The next bit of code is to generate a color if one wasn&#39;t provided (ie the application doesn&#39;t care what color), then the partition node is created, and finally, a new index space node is created for each color.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="kt">void</span> <span class="n">RegionTreeForest</span><span class="o">::</span><span class="n">create_index_partition</span><span class="p">(</span><span class="n">IndexPartition</span> <span class="n">pid</span><span class="p">,</span>
        <span class="n">IndexSpace</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">disjoint</span><span class="p">,</span> 
        <span class="kt">int</span> <span class="n">color</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span><span class="n">Domain</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">coloring</span><span class="p">,</span> <span class="n">Domain</span> <span class="n">color_space</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">IndexSpaceNode</span> <span class="o">*</span><span class="n">parent_node</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
      <span class="n">Color</span> <span class="n">part_color</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">color</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">part_color</span> <span class="o">=</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">generate_color</span><span class="p">();</span>
      <span class="k">else</span>
        <span class="n">part_color</span> <span class="o">=</span> <span class="kt">unsigned</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
      <span class="n">IndexPartNode</span> <span class="o">*</span><span class="n">new_part</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">parent_node</span><span class="p">,</span> <span class="n">part_color</span><span class="p">,</span>
                                    <span class="n">color_space</span><span class="p">,</span> <span class="n">disjoint</span><span class="p">);</span>
      <span class="c1">// Now do all the child nodes</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span><span class="n">Domain</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">coloring</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="n">it</span> <span class="o">!=</span> <span class="n">coloring</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="n">UINT_MAX</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">log_index</span><span class="p">(</span><span class="n">LEVEL_ERROR</span><span class="p">,</span><span class="s">&quot;Invalid child color UINT_MAX specified &quot;</span>
                                <span class="s">&quot;for create index partition.  All colors &quot;</span>
                                <span class="s">&quot;must be between 0 and UINT_MAX-1&quot;</span><span class="p">);</span>
          <span class="n">exit</span><span class="p">(</span><span class="n">ERROR_INVALID_PARTITION_COLOR</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Domain</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="n">domain</span><span class="p">.</span><span class="n">get_index_space</span><span class="p">(</span><span class="nb">true</span><span class="cm">/*create if necessary*/</span><span class="p">);</span>
        <span class="n">create_node</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">new_part</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
      <span class="p">}</span> 
    <span class="p">}</span>
</code></pre></div>
<h1>Query</h1>

<p>Applications may want to query information about the forest. For instance, what color corresponds to a particular index space?</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">Color</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">get_index_space_color</span><span class="p">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">IndexSpace</span> <span class="n">handle</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">forest</span><span class="o">-&gt;</span><span class="n">get_index_space_color</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>Look up the node in the forest:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">Color</span> <span class="n">RegionTreeForest</span><span class="o">::</span><span class="n">get_index_space_color</span><span class="p">(</span><span class="n">IndexSpace</span> <span class="n">handle</span><span class="p">)</span>
    <span class="c1">//--------------------------------------------------------------------------</span>
    <span class="p">{</span>
      <span class="n">IndexSpaceNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>Note that its a major problem if an application asks for an index space that doesn&#39;t exist:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">IndexSpaceNode</span><span class="o">*</span> <span class="n">RegionTreeForest</span><span class="o">::</span><span class="n">get_node</span><span class="p">(</span><span class="n">IndexSpace</span> <span class="n">space</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">AutoLock</span> <span class="n">l_lock</span><span class="p">(</span><span class="n">lookup_lock</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="cm">/*exclusive*/</span><span class="p">);</span> 
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">IndexSpace</span><span class="p">,</span><span class="n">IndexSpaceNode</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> 
        <span class="n">index_nodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">space</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">index_nodes</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="n">log_index</span><span class="p">(</span><span class="n">LEVEL_ERROR</span><span class="p">,</span><span class="s">&quot;Unable to find entry for index space &quot;</span> <span class="n">IDFMT</span> <span class="s">&quot;.&quot;</span>
                              <span class="s">&quot;This is either a runtime bug, or requires &quot;</span>
                              <span class="s">&quot;Legion fences if index space names are being &quot;</span>
                              <span class="s">&quot;returned out of the context in which they are &quot;</span>
                              <span class="s">&quot;created.&quot;</span><span class="p">,</span>
                              <span class="n">space</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">ERROR_INVALID_INDEX_SPACE_ENTRY</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>Then we have a handle from <code>get_node</code> to one of the structures in the forest. For instance in this case the index space node structure contains lots of methods specific to this node type:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">class</span> <span class="nc">IndexSpaceNode</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IndexTreeNode</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">IndexSpaceNode</span><span class="p">(</span><span class="n">Domain</span> <span class="n">d</span><span class="p">,</span> <span class="n">IndexPartNode</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span> <span class="n">Color</span> <span class="n">c</span><span class="p">,</span>
                     <span class="n">RegionTreeForest</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
      <span class="n">IndexSpaceNode</span><span class="p">(</span><span class="k">const</span> <span class="n">IndexSpaceNode</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
    <span class="p">...</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="kt">bool</span> <span class="n">has_child</span><span class="p">(</span><span class="n">Color</span> <span class="n">c</span><span class="p">);</span>
      <span class="n">IndexPartNode</span><span class="o">*</span> <span class="nf">get_child</span><span class="p">(</span><span class="n">Color</span> <span class="n">c</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">add_child</span><span class="p">(</span><span class="n">IndexPartNode</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>
    <span class="p">...</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="kt">bool</span> <span class="n">are_disjoint</span><span class="p">(</span><span class="n">Color</span> <span class="n">c1</span><span class="p">,</span> <span class="n">Color</span> <span class="n">c2</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">add_disjoint</span><span class="p">(</span><span class="n">Color</span> <span class="n">c1</span><span class="p">,</span> <span class="n">Color</span> <span class="n">c2</span><span class="p">);</span>
      <span class="n">Color</span> <span class="nf">generate_color</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">get_colors</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">colors</span><span class="p">);</span>
    <span class="p">...</span>
</code></pre></div>
<p>Likewise for the index partition node that we had shown previously:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">class</span> <span class="nc">IndexPartNode</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IndexTreeNode</span> <span class="p">{</span> 
    <span class="k">public</span><span class="o">:</span>
      <span class="n">IndexPartNode</span><span class="p">(</span><span class="n">IndexPartition</span> <span class="n">p</span><span class="p">,</span> <span class="n">IndexSpaceNode</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
                    <span class="n">Color</span> <span class="n">c</span><span class="p">,</span> <span class="n">Domain</span> <span class="n">color_space</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dis</span><span class="p">,</span>
                    <span class="n">RegionTreeForest</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
      <span class="n">IndexPartNode</span><span class="p">(</span><span class="k">const</span> <span class="n">IndexPartNode</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">IndexPartNode</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="p">...</span>
</code></pre></div>
<p>But both types inherit from <code>IndexTreeNode</code>, and that is where the color field is located:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">class</span> <span class="nc">IndexTreeNode</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>

      <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">depth</span><span class="p">;</span>
      <span class="k">const</span> <span class="n">Color</span> <span class="n">color</span><span class="p">;</span>
      <span class="n">RegionTreeForest</span> <span class="o">*</span><span class="k">const</span> <span class="n">context</span><span class="p">;</span>

    <span class="p">...</span>
</code></pre></div>
<h1>Region Trees vs Index Space Trees</h1>

<p>Recall that index space nodes in the forest are created eagerly. That policy is also true for field space, but the property doesn&#39;t hold for logical regions, because they are more complex. Instead nodes in a logical region tree are created lazily as an optimization that not all nodes in a system need to see all of the region tree, which can be quite large.</p>

<p>We can see some of the differences by looking at <code>RegionTreeForest::get_node</code> for the <code>LogicalRegion</code> node type. Note that we also grab the lookup lock, but if the node isn&#39;t found we don&#39;t throw an error, and instead we create a new node. And notice that we also recursively call <code>get_node</code> to acquire parent nodes. In this way only the path in the tree that is needed for a particular request is instantiated.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="n">RegionNode</span><span class="o">*</span> <span class="n">RegionTreeForest</span><span class="o">::</span><span class="n">get_node</span><span class="p">(</span><span class="n">LogicalRegion</span> <span class="n">handle</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">...</span>
      <span class="c1">// Check to see if the node already exists</span>
      <span class="p">{</span>
        <span class="n">AutoLock</span> <span class="n">l_lock</span><span class="p">(</span><span class="n">lookup_lock</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">false</span><span class="cm">/*exclusive*/</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">LogicalRegion</span><span class="p">,</span><span class="n">RegionNode</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> 
          <span class="n">region_nodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">region_nodes</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Otherwise it hasn&#39;t been made yet, so make it</span>
      <span class="n">IndexSpaceNode</span> <span class="o">*</span><span class="n">index_node</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">handle</span><span class="p">.</span><span class="n">index_space</span><span class="p">);</span>

      <span class="n">LogicalPartition</span> <span class="nf">parent_handle</span><span class="p">(</span><span class="n">handle</span><span class="p">.</span><span class="n">tree_id</span><span class="p">,</span> <span class="n">index_node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
                                     <span class="n">handle</span><span class="p">.</span><span class="n">field_space</span><span class="p">);</span>
      <span class="c1">// Note this request can recursively build more nodes, but we</span>
      <span class="c1">// are guaranteed that the top level node exists</span>
      <span class="n">PartitionNode</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">parent_handle</span><span class="p">);</span>
      <span class="c1">// Now make our node and then return it</span>
      <span class="k">return</span> <span class="nf">create_node</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
  </article>

  <section id="disqus_thread"></section>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'noahdesugithubcom'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">makedist</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>makedist</li>
          <li><a href="mailto:noahwatkins@gmail.com">noahwatkins@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/noahdesu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/noahdesu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Notes on programming, research, and other interests.
</p>
      </div>
    </div>

  </div>

</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37966177-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>

</html>
