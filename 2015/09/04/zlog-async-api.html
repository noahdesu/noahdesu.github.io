<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Zlog Asynchronous I/O Support</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://noahdesu.github.io/2015/09/04/zlog-async-api.html">
  <link rel="alternate" type="application/rss+xml" title="makedist" href="http://noahdesu.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">makedist</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="/legion.html">Legion</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Zlog Asynchronous I/O Support</h1>
    <p class="post-meta">Sep 4, 2015
    </p>
    <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="noahdesu">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </header>

  <article class="post-content">
    <p>As <a href="/2014/10/26/corfu-on-ceph.html">previously discussed, Zlog is an implementation of the CORFU distributed
log protocol on top of Ceph</a>. This post will discuss the basics of using the
API, and provide details on the new asynchronous API design.</p>

<h1>Zlog API Example</h1>

<p>First create a connection to the sequencer service:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">zlog</span><span class="o">::</span><span class="n">SeqrClient</span> <span class="n">seqr</span><span class="p">(</span><span class="s">&quot;localhost&quot;</span><span class="p">,</span> <span class="s">&quot;5678&quot;</span><span class="p">);</span>
</code></pre></div>
<p>Next create a brand new log. A given log is striped across objects in a RADOS
pool.  When you create a new log provide a handle to the pool, as well as a
striping width and a name for the log.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="kt">int</span> <span class="n">stripe_width</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">zlog</span><span class="o">::</span><span class="n">Log</span> <span class="n">log</span><span class="p">;</span>
<span class="n">zlog</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">ioctx</span><span class="p">,</span> <span class="s">&quot;mylog&quot;</span><span class="p">,</span> <span class="n">stripe_width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seqr</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
</code></pre></div>
<p>Now the log is available to use. In the following code snippet a string is
appended to the log which returns the position at which the string was stored.
Finally the string at the reported position is read back and verified.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span> <span class="n">bl_in</span><span class="p">;</span>
<span class="n">bl_in</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;My first log entry&quot;</span><span class="p">);</span>

<span class="kt">uint64_t</span> <span class="n">pos</span><span class="p">;</span>
<span class="n">log</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">bl_in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>

<span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span> <span class="n">bl_out</span><span class="p">;</span>
<span class="n">log</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">bl_out</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">bl_in</span> <span class="o">==</span> <span class="n">bl_out</span><span class="p">);</span>
</code></pre></div>
<p>Next we&#39;ll discuss the asynchronous versions of <code>Read</code> and <code>Append</code>.</p>

<h1>Asynchronous API</h1>

<p>The two components of the asynchronous interface that we&#39;ll discuss today are
<code>AioAppend</code> and <code>AioRead</code>, which are the asynchronous versions of
<code>Log::Append</code> and <code>Log::Read</code>, respectively:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="cm">/*</span>
<span class="cm"> * Append data asynchronously to the log and return its position.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">AioAppend</span><span class="p">(</span><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">pposition</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Read data asynchronously from the log.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">AioRead</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">position</span><span class="p">,</span> <span class="n">AioCompletion</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
    <span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span> <span class="o">*</span><span class="n">bpl</span><span class="p">);</span>
</code></pre></div>
<p>The append interface <code>AioAppend</code> takes a completion context, a blob of data
that will be appended, and an optional output parameter that upon success will
contain the final location of the data that was appended to the log.
Similarly, <code>AioRead</code> will populate the output data parameter with the
contents of the log at the provided location (assuming it exists).</p>

<p>The <code>AioCompletion</code> object holds context for the invocation, and is used to
discover if the operation was successful. To use the API one must first create
an <code>AioCompletion</code> object. The following creates a basic completion object
with no callbacks:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">zlog</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">aio_create_completion</span><span class="p">();</span>
</code></pre></div>
<p>The API also allows a callback to be defined that will automatically be called
upon when the operation has completed (either successfully or not). The
following creates a completion object that will use <code>aio_cb</code> as the callback,
and will pass a pointer to an <code>AioState</code> object that upon successfully
appending data will contain the final position. Note that the completion
object is used to interogate the return value of the operation using
<code>AioCompletion::get_return_value()</code>:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="n">AioState</span> <span class="p">{</span>
  <span class="n">Log</span><span class="o">::</span><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">position</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">aio_cb</span><span class="p">(</span><span class="kt">completion_t</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">AioState</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">AioState</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">get_return_value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;pos: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;pos: error&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">AioState</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AioState</span><span class="p">;</span>
<span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span> <span class="n">bl</span><span class="p">;</span> <span class="c1">// data to append</span>
<span class="n">s</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">Log</span><span class="o">::</span><span class="n">aio_create_completion</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">aio_cb</span><span class="p">);</span>
</code></pre></div>
<p>Once the callback and completion have been setup, use <code>AioAppend</code> to dispatch
the operation:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">log</span><span class="p">.</span><span class="n">AioAppend</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="n">bl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">);</span>
</code></pre></div>
<p>A thread can block until an asychronous operation completes by using
<code>AioCompletion::wait_for_complete()</code>:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">s</span><span class="o">-&gt;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">wait_on_complete</span><span class="p">();</span>
</code></pre></div>
<p>When a completion is no long used the application should free the object using
the <code>AioCompletion::release()</code> interface:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">s</span><span class="o">-&gt;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</code></pre></div>
<h1>Asynchronous API Implementation</h1>

<p>Building an asynchronous API for Zlog can be challenging because some
interface (e.g. <code>Append</code>) may need to retry using a new position. Rather than
completely reinvent the internal guts of an asynchronous API I instead have
built the API as a layer on top of the RADOS asychronous API.</p>

<p>When a new AIO completion context is created we build a data structure that
holds information about the context:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">Log</span><span class="o">::</span><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">Log</span><span class="o">::</span><span class="n">aio_create_completion</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
    <span class="n">Log</span><span class="o">::</span><span class="n">AioCompletion</span><span class="o">::</span><span class="kt">callback_t</span> <span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">AioCompletionImpl</span> <span class="o">*</span><span class="n">impl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AioCompletionImpl</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">safe_cb</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">safe_cb_arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">AioCompletion</span><span class="p">(</span><span class="n">impl</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Log</span><span class="o">::</span><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">Log</span><span class="o">::</span><span class="n">aio_create_completion</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">aio_create_completion</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The internal completion object contains several pieces of state:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="n">zlog</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">AioCompletionImpl</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cond</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">complete</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">released</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div>
<p>The above state are used to control concurreny, and track users of the
completion object. Next we have some more interesting components:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">...
  /*
   * Common
   *
   * position:
   *   - current attempt (append)
   *   - target (read)
   * bl:
   *  - data being appended (append)
   *  - temp storage for read (read)
   */
  int retval;
  Log::AioCompletion::callback_t safe_cb;
  void *safe_cb_arg;
  uint64_t position;
  ceph::bufferlist bl;
  AioType type;
...
</code></pre></div>
<p>The above are common to all types of asychronous operations (currently reads
and appends). The <code>retval</code> component holds the <em>final</em> return value of the operation
as if the synchronous version of <code>Log::Append</code> or <code>Log::Read</code> were called.
Next are the callback function pointer and callback context stored when the
completion was created. The <code>position</code> element holds the final location for
appends, or the target location for reads. Data for reads and appends are
stored in <code>bl</code>, and <code>type</code> marks the type of operation (currently read or
append). Next we have type-specific fields:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="p">...</span>
  <span class="cm">/*</span>
<span class="cm">   * AioAppend</span>
<span class="cm">   *</span>
<span class="cm">   * pposition:</span>
<span class="cm">   *  - final append position</span>
<span class="cm">   */</span>
  <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">pposition</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div>
<p>This pointer is used to store the location that the final position on an
append should be stored which is provided by the API client.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="p">...</span>
  <span class="cm">/*</span>
<span class="cm">   * AioRead</span>
<span class="cm">   *</span>
<span class="cm">   * pbl:</span>
<span class="cm">   *  - where to put result</span>
<span class="cm">   */</span>
  <span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span> <span class="o">*</span><span class="n">pbl</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div>
<p>Likewise for a read the <code>pbl</code> pointer specifies where the retrieved data
should be stored.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="p">...</span>
  <span class="n">Log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>
  <span class="n">librados</span><span class="o">::</span><span class="n">IoCtx</span> <span class="o">*</span><span class="n">ioctx</span><span class="p">;</span>
  <span class="n">librados</span><span class="o">::</span><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Finally, a reference to the underlying log and RADOS context are stored, along
with the RADOS completion context.</p>

<h2>Setup of Append Operation</h2>

<p>The intial setup involves first looking up the current tail position. This is
our first guess about where the data will be appended.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">Log</span><span class="o">::</span><span class="n">AioAppend</span><span class="p">(</span><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">pposition</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// initial position guess</span>
  <span class="kt">uint64_t</span> <span class="n">position</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">CheckTail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">position</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</code></pre></div>
<p>Next the AIO completion context is filled in (see above for a description of
all these fields).</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="n">AioCompletionImpl</span> <span class="o">*</span><span class="n">impl</span> <span class="o">=</span> <span class="p">(</span><span class="n">AioCompletionImpl</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">;</span>

  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">log</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">bl</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">pposition</span> <span class="o">=</span> <span class="n">pposition</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">ioctx</span> <span class="o">=</span> <span class="n">ioctx_</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ZLOG_AIO_APPEND</span><span class="p">;</span>
</code></pre></div>
<p>A reference is acquired on behalf of the client, and the underlying RADOS
completion object is created. Note that the RADOS completion is setup to use
<code>aio_safe_cb</code> as the callback which implements the retry logic for appending
which we&#39;ll discuss later.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span> <span class="c1">// rados aio now has a reference</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">librados</span><span class="o">::</span><span class="n">Rados</span><span class="o">::</span><span class="n">aio_create_completion</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">aio_safe_cb</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
</code></pre></div>
<p>Finally we create and dispatch the asynchronous operation and immediately
return the caller.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="n">librados</span><span class="o">::</span><span class="n">ObjectWriteOperation</span> <span class="n">op</span><span class="p">;</span>
  <span class="n">zlog</span><span class="o">::</span><span class="n">cls_zlog_write</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">epoch_</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">oid</span> <span class="o">=</span> <span class="n">position_to_oid</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctx_</span><span class="o">-&gt;</span><span class="n">aio_operate</span><span class="p">(</span><span class="n">oid</span><span class="p">,</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2>Setup of Read Operation</h2>

<p>Setup for <code>AioRead</code> is easy. First the context is filled in:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">Log</span><span class="o">::</span><span class="n">AioRead</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">position</span><span class="p">,</span> <span class="n">AioCompletion</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
    <span class="n">ceph</span><span class="o">::</span><span class="n">bufferlist</span> <span class="o">*</span><span class="n">pbl</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">AioCompletionImpl</span> <span class="o">*</span><span class="n">impl</span> <span class="o">=</span> <span class="p">(</span><span class="n">AioCompletionImpl</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">;</span>

  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">log</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">pbl</span> <span class="o">=</span> <span class="n">pbl</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">ioctx</span> <span class="o">=</span> <span class="n">ioctx_</span><span class="p">;</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ZLOG_AIO_READ</span><span class="p">;</span>
</code></pre></div>
<p>Grab a reference for the caller, and setup the underlying RADOS callback which
uses the same callback as <code>AioAppend</code>:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span> <span class="c1">// rados aio now has a reference</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">librados</span><span class="o">::</span><span class="n">Rados</span><span class="o">::</span><span class="n">aio_create_completion</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">aio_safe_cb</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
</code></pre></div>
<p>Finally the operation is prepared and asynchronously dispatched, immediately
returning to the caller.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="n">librados</span><span class="o">::</span><span class="n">ObjectReadOperation</span> <span class="n">op</span><span class="p">;</span>
  <span class="n">zlog</span><span class="o">::</span><span class="n">cls_zlog_read</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">epoch_</span><span class="p">,</span> <span class="n">position</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">oid</span> <span class="o">=</span> <span class="n">position_to_oid</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctx_</span><span class="o">-&gt;</span><span class="n">aio_operate</span><span class="p">(</span><span class="n">oid</span><span class="p">,</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">bl</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2>Asynchronous Callback</h2>

<p>The guts of the asynchronous API are in the callback which implements the Zlog
specific semantics on top of the underlying RADOS callback mechanism. Note
that this callback is invovked when the underlying RADOS operation completes
successfully or experiences a failure, so both cases must be handled.
Additionally, this is used to handle both reads and appends.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">aio_safe_cb</span><span class="p">(</span><span class="n">librados</span><span class="o">::</span><span class="kt">completion_t</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">zlog</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">AioCompletionImpl</span> <span class="o">*</span><span class="n">impl</span> <span class="o">=</span> <span class="p">(</span><span class="n">zlog</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">AioCompletionImpl</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
  <span class="n">librados</span><span class="o">::</span><span class="n">AioCompletion</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">finish</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">get_return_value</span><span class="p">();</span>

  <span class="c1">// done with the rados completion</span>
  <span class="n">rc</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_APPEND</span> <span class="o">||</span>
         <span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_READ</span><span class="p">);</span>
</code></pre></div>
<p>When the callback is made we first initialize the <code>finish</code> variable to false
which indicates whether or not we will dispatch a new RADOS operation
asychronously (e.g. retrying an append), or invoke the Zlog client callback.
The value stored in <code>ret</code> contains the return value of the RADOS operation,
and we immediately release the resources associated with the RADOS completion
object which won&#39;t be needed further.</p>

<p>Next we perform tasks based on the return value. First we consider the case
that everything succeeded on the RADOS side:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">zlog</span><span class="o">::</span><span class="n">CLS_ZLOG_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">     * Append was successful. We&#39;re done.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_APPEND</span> <span class="o">&amp;&amp;</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">pposition</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">pposition</span> <span class="o">=</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_READ</span> <span class="o">&amp;&amp;</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">pbl</span> <span class="o">&amp;&amp;</span>
        <span class="n">impl</span><span class="o">-&gt;</span><span class="n">bl</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">pbl</span> <span class="o">=</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">bl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div>
<p>If an append is being performed, then we write the final position back into
the location specified by the client. If a read is being performed we copy the
data back to the client. Note that in this case we also are done, so we set
<code>finish</code> to be true.</p>

<p>Next we consider the case that the operation was tagged with a stale epoch
value. In this case we want to resubmit the operation again with a new epoch
value. First we refresh the log. If an error occured during refresh we will
return an error to the client, hence we set <code>finish</code> to be true. Otherwise if
the refresh was successful we fall through.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">zlog</span><span class="o">::</span><span class="n">CLS_ZLOG_STALE_EPOCH</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">     * We&#39;ll need to try again with a new epoch.</span>
<span class="cm">     */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">RefreshProjection</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
      <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div>
<p>Next we consider a generic RADOS error which will also result in returning the
error to the client.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">     * Encountered a RADOS error.</span>
<span class="cm">     */</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div>
<p>The operation could also encounter a <code>NOT_WRITTEN</code> state which is returned to
the client, but we assert invariants of the protocol which state that this
return value is only valid if a read is being performed. The case is the same
for the <code>INVALIDATED</code> return value.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">zlog</span><span class="o">::</span><span class="n">CLS_ZLOG_NOT_WRITTEN</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_READ</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">zlog</span><span class="o">::</span><span class="n">CLS_ZLOG_INVALIDATED</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_READ</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</code></pre></div>
<p>The final case is that an append is being performed and the position was
marked as <code>READ_ONLY</code>. All other cases are major failures.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="k">if</span> <span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_APPEND</span><span class="p">)</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">zlog</span><span class="o">::</span><span class="n">CLS_ZLOG_READ_ONLY</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="nf">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>
<p>If <code>finish</code> is false then we will not yet return to the client because there
needs to be a retry of the operation. First, if an append is happening then we
must get a new tail position to try.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">finish</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ZLOG_AIO_APPEND</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// if we are appending, get a new position</span>
      <span class="kt">uint64_t</span> <span class="n">position</span><span class="p">;</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">CheckTail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">position</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">impl</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>If a failure occurs we return to the client, otherwise we setup a new RADOS
completion object and prepare it.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">    <span class="c1">// we are still good. build a new aio</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">finish</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">librados</span><span class="o">::</span><span class="n">Rados</span><span class="o">::</span><span class="n">aio_create_completion</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">aio_safe_cb</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
      <span class="c1">// don&#39;t need impl-&gt;get(): reuse reference</span>
</code></pre></div>
<p>Finally we do any operation-specific setup and resubmit the operation which
will result in this callback being invoked again asynchronously.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">      // build and submit new op
      std::string oid = impl-&gt;log-&gt;position_to_oid(impl-&gt;position);
      switch (impl-&gt;type) {
        case ZLOG_AIO_APPEND:
          {
            librados::ObjectWriteOperation op;
            zlog::cls_zlog_write(op, impl-&gt;log-&gt;epoch_, impl-&gt;position, impl-&gt;bl);
            ret = impl-&gt;ioctx-&gt;aio_operate(oid, impl-&gt;c, &amp;op);
            if (ret)
              finish = true;
          }
          break;

        case ZLOG_AIO_READ:
          {
            librados::ObjectReadOperation op;
            zlog::cls_zlog_read(op, impl-&gt;log-&gt;epoch_, impl-&gt;position);
            ret = impl-&gt;ioctx-&gt;aio_operate(oid, impl-&gt;c, &amp;op, &amp;impl-&gt;bl);
            if (ret)
              finish = true;
          }
          break;

        default:
          assert(0);
      }
    }
  }
</code></pre></div>
<p>This retry process continues until success or error occurs which will set
<code>finish</code> to be true. In this case the Zlog completion object is finalized and
the client callback is invoked.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++">  <span class="c1">// complete aio if append success, or any error</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">finish</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">safe_cb</span><span class="p">)</span>
      <span class="n">impl</span><span class="o">-&gt;</span><span class="n">safe_cb</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">safe_cb_arg</span><span class="p">);</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">put_unlock</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>And that is it. Without utilizing the RADOS asynchronous interface a lot more
infrastructure would have to have been created.</p>

  </article>

  <section id="disqus_thread"></section>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'noahdesugithubcom'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">makedist</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>makedist</li>
          <li><a href="mailto:noahwatkins@gmail.com">noahwatkins@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/noahdesu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/noahdesu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Notes on programming, research, and other interests.
</p>
      </div>
    </div>

  </div>

</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37966177-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>

</html>
