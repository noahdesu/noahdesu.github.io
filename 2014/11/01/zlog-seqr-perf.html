<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Zlog sequencer performance</title>
  <meta name="description" content="In a previous post we discussed the design of zlog,our implementation of the CORFU distributedshared-log protocol on top of Ceph. A key component of the syst...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://noahdesu.github.io/2014/11/01/zlog-seqr-perf.html">
  <link rel="alternate" type="application/rss+xml" title="makedist" href="http://noahdesu.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">makedist</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
          <a class="page-link" href="/legion.html">Legion</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Zlog sequencer performance</h1>
    <p class="post-meta">Nov 1, 2014
    </p>
    <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="noahdesu">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </header>

  <article class="post-content">
    <p>In a <a href="/2014/10/26/corfu-on-ceph.html">previous post we discussed the design of zlog</a>,
our implementation of the <a href="http://research.microsoft.com/en-us/projects/corfu/">CORFU</a> distributed
shared-log protocol on top of <a href="http://ceph.com">Ceph</a>. A key component of the system is the
sequencer server that reports the current log tail to clients.  In this post
we&#39;ll discuss the implementation and performance of the sequencer in
<a href="http://github.com/noahdesu/zlog">zlog</a>.</p>

<p>The fast path of the sequencer server is simple. It contains an in-memory
counter that is incremented when a client requests the next position in the
log. Our current implementation receive requests from clients that are about
60 bytes in size (log identifier, epoch value), and responds with the
current counter and epoch totaling about 16 bytes. The current design achieves
approximately 180K requests per second with 4 server threads on the loopback
interface, and approximately 100K requests per second over the 10 Gb ethernet
network on Google Compute Engine.</p>

<p>In contrast, the authors of the <a href="http://muratbuffalo.blogspot.com/2014/09/paper-summary-tango-distributed-data.html">Tango</a> paper report sequencer performance of
approximately 500K requests per second over a 1 Gb ethernet link. While 100K
requests per second for our implementation is more than enough to get started
with some interesting applications, it would be nice to reach parity with the
results in the Tango paper.</p>

<p>In the remainder of this paper we&#39;ll discuss the current implementation. If
anyone has suggestions on improving performance that would be great :)</p>

<h1>Protocol</h1>

<p>Our implementation uses Google Protocol Buffers to encode messages between
clients and the sequencer. Below is the specification for the messages. The
<code>MSeqRequest</code> is sent by clients, and the <code>MSeqReply</code> is the message type of
each server reply.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">zlog_proto</span><span class="o">;</span>

<span class="n">option</span> <span class="n">optimize_for</span> <span class="o">=</span> <span class="n">SPEED</span><span class="o">;</span>

<span class="n">message</span> <span class="n">MSeqRequest</span> <span class="o">{</span>
    <span class="n">required</span> <span class="n">uint64</span> <span class="n">epoch</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">required</span> <span class="n">string</span> <span class="n">pool</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="n">required</span> <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="n">required</span> <span class="n">bool</span> <span class="n">next</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">message</span> <span class="n">MSeqReply</span> <span class="o">{</span>
    <span class="kd">enum</span> <span class="n">Status</span> <span class="o">{</span>
        <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">INIT_LOG</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">STALE_EPOCH</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">required</span> <span class="n">uint64</span> <span class="n">position</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">optional</span> <span class="n">Status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">[</span><span class="k">default</span> <span class="o">=</span> <span class="n">OK</span><span class="o">];</span>
<span class="o">}</span></code></pre></figure>

<p>Next we&#39;ll discuss the server and client designs.</p>

<h1>Server</h1>

<p>When the server starts up it binds to a specific port <code>--port</code> and starts a
set of worker threads <code>--nthreads</code>. The server can also be daemonized but this
code has been removed for brevity. The <code>LogManager</code> object tracks log metadata
and is used by the server.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">host</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nthreads</span><span class="p">;</span>

  <span class="n">po</span><span class="o">::</span><span class="n">options_description</span> <span class="n">desc</span><span class="p">(</span><span class="s">&quot;Allowed options&quot;</span><span class="p">);</span>
  <span class="n">desc</span><span class="p">.</span><span class="n">add_options</span><span class="p">()</span>
    <span class="p">(</span><span class="s">&quot;port&quot;</span><span class="p">,</span> <span class="n">po</span><span class="o">::</span><span class="n">value</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">required</span><span class="p">(),</span> <span class="s">&quot;Server port&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;nthreads&quot;</span><span class="p">,</span> <span class="n">po</span><span class="o">::</span><span class="n">value</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nthreads</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">default_value</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s">&quot;Num threads&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;report-sec&quot;</span><span class="p">,</span> <span class="n">po</span><span class="o">::</span><span class="n">value</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">report_sec</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">default_value</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;Time between rate reports&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;daemon,d&quot;</span><span class="p">,</span> <span class="s">&quot;Run in background&quot;</span><span class="p">)</span>
  <span class="p">;</span>

  <span class="n">po</span><span class="o">::</span><span class="n">variables_map</span> <span class="n">vm</span><span class="p">;</span>
  <span class="n">po</span><span class="o">::</span><span class="n">store</span><span class="p">(</span><span class="n">po</span><span class="o">::</span><span class="n">parse_command_line</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">desc</span><span class="p">),</span> <span class="n">vm</span><span class="p">);</span>
  <span class="n">po</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nthreads</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
    <span class="n">nthreads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">Server</span> <span class="n">s</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">);</span>
  <span class="n">log_mgr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LogManager</span><span class="p">();</span>
  <span class="n">s</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The server design uses Boost ASIO and is based on the multi-threaded HTTP
server example available on the Boost ASIO website. The server contains a
single I/O service object, and we set the <code>TCP_NODELAY</code> option for all new connections.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Server</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Server</span><span class="p">(</span><span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nthreads</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">acceptor_</span><span class="p">(</span><span class="n">io_service_</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">endpoint</span><span class="p">(</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="n">port</span><span class="p">)),</span>
      <span class="n">nthreads_</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">acceptor_</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">no_delay</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
    <span class="n">start_accept</span><span class="p">();</span>
  <span class="p">}</span></code></pre></figure>

<p>When the server starts a set of threads all call the <code>run</code> method on the I/O
service object.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">  <span class="kt">void</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="kr">thread</span><span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">::</span><span class="n">run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_service_</span><span class="p">)));</span>
      <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">join</span><span class="p">();</span>
  <span class="p">}</span></code></pre></figure>

<p>New connections are handled by the state machine implemented in the <code>Session</code>
object that we&#39;ll see next.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"> <span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">start_accept</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Session</span><span class="o">*</span> <span class="n">new_session</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Session</span><span class="p">(</span><span class="n">io_service_</span><span class="p">);</span>
    <span class="n">acceptor_</span><span class="p">.</span><span class="n">async_accept</span><span class="p">(</span><span class="n">new_session</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">(),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Server</span><span class="o">::</span><span class="n">handle_accept</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">new_session</span><span class="p">,</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">handle_accept</span><span class="p">(</span><span class="n">Session</span><span class="o">*</span> <span class="n">new_session</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
      <span class="n">new_session</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="k">delete</span> <span class="n">new_session</span><span class="p">;</span>
    <span class="n">start_accept</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">io_service_</span><span class="p">;</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">acceptor_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nthreads_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<h2>Session</h2>

<p>The <code>Session</code> object implements the sequencer protocol state machine. Each
connection starts with the client sending us a 32-bit message header.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">  <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">async_read</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Session</span><span class="o">::</span><span class="n">handle_hdr</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">,</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">bytes_transferred</span><span class="p">));</span>
  <span class="p">}</span></code></pre></figure>

<p>Next we sanity check the header and read the rest of the message.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">  <span class="kt">void</span> <span class="nf">handle_hdr</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint32_t</span> <span class="n">msg_size</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">buffer_</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">msg_size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer_</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;message is too large&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">async_read</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_</span><span class="p">,</span> <span class="n">msg_size</span><span class="p">),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Session</span><span class="o">::</span><span class="n">handle_msg</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">,</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">bytes_transferred</span><span class="p">));</span>
  <span class="p">}</span></code></pre></figure>

<p>Next we handle the part of the message with the interesting parts. We start by
re-setting a <code>MSeqRequest</code> and initializing it with the received data.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">  <span class="kt">void</span> <span class="nf">handle_msg</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">req_</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req_</span><span class="p">.</span><span class="n">ParseFromArray</span><span class="p">(</span><span class="n">buffer_</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;failed to parse message&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req_</span><span class="p">.</span><span class="n">IsInitialized</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;received incomplete message&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>Next we prepare a <code>MSeqReply</code> structure and contact the <code>LogManager</code> with the
information in the request. We&#39;ll discuss the <code>LogManager</code> in the next
section.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="n">reply_</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">seq</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">log_mgr</span><span class="o">-&gt;</span><span class="n">ReadSequence</span><span class="p">(</span><span class="n">req_</span><span class="p">.</span><span class="n">pool</span><span class="p">(),</span> <span class="n">req_</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span>
        <span class="n">req_</span><span class="p">.</span><span class="n">epoch</span><span class="p">(),</span> <span class="n">req_</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
      <span class="n">reply_</span><span class="p">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">zlog_proto</span><span class="o">::</span><span class="n">MSeqReply</span><span class="o">::</span><span class="n">INIT_LOG</span><span class="p">);</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">)</span>
      <span class="n">reply_</span><span class="p">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">zlog_proto</span><span class="o">::</span><span class="n">MSeqReply</span><span class="o">::</span><span class="n">STALE_EPOCH</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="nf">assert</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">);</span></code></pre></figure>

<p>Once the <code>LogManager</code> is finished, we record any errors that occurred, and set
the position reported by the <code>LogManager</code> and send out the reply back to the
client.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="n">reply_</span><span class="p">.</span><span class="n">set_position</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">reply_</span><span class="p">.</span><span class="n">IsInitialized</span><span class="p">());</span>

    <span class="kt">uint32_t</span> <span class="n">msg_size</span> <span class="o">=</span> <span class="n">reply_</span><span class="p">.</span><span class="n">ByteSize</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">msg_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer_</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">reply_</span><span class="p">.</span><span class="n">SerializeToArray</span><span class="p">(</span><span class="n">buffer_</span><span class="p">,</span> <span class="n">msg_size</span><span class="p">));</span>

    <span class="c1">// scatter/gather buffers</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">const_buffer</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">be_msg_size_</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">msg_size</span><span class="p">);</span>
    <span class="n">out</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">be_msg_size_</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">be_msg_size_</span><span class="p">)));</span>
    <span class="n">out</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_</span><span class="p">,</span> <span class="n">msg_size</span><span class="p">));</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">async_write</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Session</span><span class="o">::</span><span class="n">handle_reply</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">,</span>
          <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">bytes_transferred</span><span class="p">));</span>
  <span class="p">}</span></code></pre></figure>

<p>Next we&#39;ll present the <code>LogManager</code> component of the sequencer server.</p>

<h2>Log Manager</h2>

<p>The <code>LogManager</code> manages the mapping between log identifiers and the actual
tail counter. A tail is represented by a <code>Sequence</code> object:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Sequence</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Sequence</span><span class="p">()</span> <span class="o">:</span> <span class="n">seq_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">Sequence</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">seq</span><span class="p">)</span> <span class="o">:</span> <span class="n">seq_</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">uint64_t</span> <span class="n">read</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">seq_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">inc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">seq_</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">uint64_t</span> <span class="n">seq_</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>A log is identified by the tuple <code>(name, pool)</code> and stored in the <code>LogManager</code>
in the <code>Log</code> struct that includes the current <code>epoch</code> value for the log
instance:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">  <span class="k">struct</span> <span class="n">Log</span> <span class="p">{</span>
    <span class="n">Log</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">Log</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">epoch</span><span class="p">)</span> <span class="o">:</span> <span class="n">seq</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Sequence</span> <span class="n">seq</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">epoch</span><span class="p">;</span>
  <span class="p">};</span></code></pre></figure>

<p>The important part is when the log sequences are read and incremented. This is
handled by the <code>ReadSequence</code> method called from the server <code>Session</code> object
in responce to a client request. The routine looks up the log in a <code>std::map</code>
and if it exists the sequence value is returned, and optionally incremented.
If the log isn&#39;t found in the index the client recieves an <code>-EAGAIN</code> message
and a request to register the log is placed in a queue. A separate thread
handles the registration of a new log in the <code>LogManager</code> because it is an
expensive process that would otherwise block other client requests.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">  <span class="kt">uint64_t</span> <span class="nf">ReadSequence</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pool</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
      <span class="kt">uint64_t</span> <span class="n">epoch</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">increment</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Log</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span>
      <span class="n">logs_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">logs_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">QueueLogInit</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">epoch</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">increment</span><span class="p">)</span>
      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">seq</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span>

    <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">seq</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span></code></pre></figure>

<p>The process of registering a new log includes the slow tail finding mechanism,
but is omitted here because it isn&#39;t part of the fast path. Next we&#39;ll show
the client side, which is very straight-forward.</p>

<h1>Client</h1>

<p>A client starts by connecting to the sequencer server.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">SeqrClient</span><span class="o">::</span><span class="n">Connect</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span> <span class="n">resolver</span><span class="p">(</span><span class="n">io_service_</span><span class="p">);</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span><span class="o">::</span><span class="n">query</span> <span class="n">query</span><span class="p">(</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="n">host_</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">port_</span><span class="p">);</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">resolver</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="n">iterator</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Client requests are in the form of a <code>MSeqRequest</code> object and include the
metadata for identifying the log.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">SeqrClient</span><span class="o">::</span><span class="n">CheckTail</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">epoch</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pool</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">position</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// fill in msg</span>
  <span class="n">zlog_proto</span><span class="o">::</span><span class="n">MSeqRequest</span> <span class="n">req</span><span class="p">;</span>
  <span class="n">req</span><span class="p">.</span><span class="n">set_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">);</span>
  <span class="n">req</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
  <span class="n">req</span><span class="p">.</span><span class="n">set_next</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
  <span class="n">req</span><span class="p">.</span><span class="n">set_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

  <span class="c1">// serialize header and protobuf message</span>
  <span class="kt">uint32_t</span> <span class="n">msg_size</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">ByteSize</span><span class="p">();</span>
  <span class="kt">uint32_t</span> <span class="n">be_msg_size</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">msg_size</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">total_msg_size</span> <span class="o">=</span> <span class="n">msg_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">be_msg_size</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">total_msg_size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

  <span class="c1">// add header</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">be_msg_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">be_msg_size</span><span class="p">));</span>

  <span class="c1">// add protobuf msg</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">IsInitialized</span><span class="p">());</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">SerializeToArray</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">be_msg_size</span><span class="p">),</span> <span class="n">msg_size</span><span class="p">));</span>

  <span class="c1">// send</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">total_msg_size</span><span class="p">));</span></code></pre></figure>

<p>The <code>write</code> call is blocking, so after it returns we read the response from
the same socket.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">  <span class="c1">// get reply</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">be_msg_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">be_msg_size</span><span class="p">)));</span>
  <span class="n">msg_size</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">be_msg_size</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">msg_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">msg_size</span><span class="p">));</span>

  <span class="c1">// deserialize</span>
  <span class="n">zlog_proto</span><span class="o">::</span><span class="n">MSeqReply</span> <span class="n">reply</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">ParseFromArray</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">msg_size</span><span class="p">));</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">IsInitialized</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">status</span><span class="p">()</span> <span class="o">==</span> <span class="n">zlog_proto</span><span class="o">::</span><span class="n">MSeqReply</span><span class="o">::</span><span class="n">INIT_LOG</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">status</span><span class="p">()</span> <span class="o">==</span> <span class="n">zlog_proto</span><span class="o">::</span><span class="n">MSeqReply</span><span class="o">::</span><span class="n">STALE_EPOCH</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">status</span><span class="p">()</span> <span class="o">==</span> <span class="n">zlog_proto</span><span class="o">::</span><span class="n">MSeqReply</span><span class="o">::</span><span class="n">OK</span><span class="p">);</span>
    <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="n">reply</span><span class="p">.</span><span class="n">position</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>And that&#39;s it. Performance is OK at 100K requests per second, but it would be
nice to reach the reported 500K requests per second form the Tango paper.</p>

<h1>Thoughts</h1>

<p>I haven&#39;t had much time to focus on optimizing the server.</p>

<ol>
<li><p>Some simple hacks suggest that the use of the <code>std::map</code> and shared locking
aren&#39;t currently a bottleneck.</p></li>
<li><p>Apparently there is locking in the I/O service, and we could use multiple
I/O service objects, but I&#39;m not familiar enough with Boost ASIO internals to
know if this is worth the effort.</p></li>
</ol>

<p>I&#39;ll be revisting sequencer performance in the future, and will now be
focusing on building some applications on top of <code>zlog</code> for demonstration.</p>

  </article>

  <section id="disqus_thread"></section>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'noahdesugithubcom'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">makedist</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>makedist</li>
          <li><a href="mailto:noahwatkins@gmail.com">noahwatkins@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/noahdesu">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/noahdesu">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">noahdesu</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Notes on programming, research, and other interests.
</p>
      </div>
    </div>

  </div>

</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37966177-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>

</html>
